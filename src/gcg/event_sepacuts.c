/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*  Copyright (c) 2002-2024 Zuse Institute Berlin (ZIB)                      */
/*                                                                           */
/*  Licensed under the Apache License, Version 2.0 (the "License");          */
/*  you may not use this file except in compliance with the License.         */
/*  You may obtain a copy of the License at                                  */
/*                                                                           */
/*      http://www.apache.org/licenses/LICENSE-2.0                           */
/*                                                                           */
/*  Unless required by applicable law or agreed to in writing, software      */
/*  distributed under the License is distributed on an "AS IS" BASIS,        */
/*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*  See the License for the specific language governing permissions and      */
/*  limitations under the License.                                           */
/*                                                                           */
/*  You should have received a copy of the Apache-2.0 license                */
/*  along with SCIP; see the file LICENSE. If not visit scipopt.org.         */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file        event_sepacuts.c
 * @ingroup     DEFPLUGINS_EVENT
 * @brief       event handler which manages the active master separator cuts
 * @author      Chantal Reinartz Groba
 */

/*--+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/
//#define SCIP_DEBUG

#include <scip/pub_tree.h>
#include <scip/scip_mem.h>
#include <scip/struct_scip.h>
#include <scip/struct_tree.h>
#include <scip/type_event.h>

#include "cons_masterbranch.h"
#include "event_sepacuts.h"
#include "gcg.h"
#include "mastercutdata.h"
#include "mastersepacut.h"
#include "misc_varhistory.h"
#include "struct_mastersepacut.h"
#include "type_sepagcg.h"


#define EVENTHDLR_NAME         "sepacuts"
#define EVENTHDLR_DESC         "event handler for keeping master cuts generated by a separator up-to-date"
#define STARTMAXCUTS            50

/*
 * Data structures
 */


/** event handler data */
struct SCIP_EventhdlrData
{
   GCG_MASTERSEPACUT**        generatedcuts;          /**< arrays of newly generated cuts: cuts were added to sepa store */
   GCG_MASTERSEPACUT**        activecuts;             /**< arrays of active cuts: cuts are part of the current LP */
   SCIP_HASHMAP*              rowxgeneratedmap;       /**< maps a row to the index of its master separator cut in generated cuts */
   int                        nactivecuts;            /**< number of active cuts */
   int                        ngeneratedcuts;         /**< number of newly generated cuts */
   int                        activecutssize;         /**< size of memory allocated in active cuts */
   int                        generatedcutssize;      /**< size of memory allocated in generated cuts */
};

/*
 * Local methods
 */

/** ensures that generated cuts has enough allocated memory to store specified number of elements */
static
SCIP_RETCODE ensureGeneratedSize(
   SCIP*                masterscip,             /**< SCIP data structure */
   SCIP_EVENTHDLRDATA*  eventhdlrdata,          /**< event handler data data structure */
   int                  size                    /**< number of elements generated cuts should be able to hold */
)
{
   assert(masterscip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->generatedcuts != NULL);
   assert(eventhdlrdata->generatedcuts != NULL);
   assert(eventhdlrdata->ngeneratedcuts <= eventhdlrdata->generatedcutssize);
   assert(eventhdlrdata->ngeneratedcuts >= 0);

   if( eventhdlrdata->generatedcutssize < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(masterscip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(masterscip, &(eventhdlrdata->generatedcuts), eventhdlrdata->generatedcutssize,
                                             newmaxcuts) );
      eventhdlrdata->generatedcutssize = newmaxcuts;
   }

   assert(eventhdlrdata->generatedcutssize >= size);

   return SCIP_OKAY;
}

/** ensures that active cuts has enough allocated memory to store specified number of elements */
static
SCIP_RETCODE ensureActiveSize(
   SCIP*                   masterscip,         /**< SCIP data structure */
   SCIP_EVENTHDLRDATA*     eventhdlrdata,      /**< event handler data data structure */
   int                     size                /**< number of elements active cuts should be able to hold */
)
{
   assert(masterscip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->activecuts != NULL);
   assert(eventhdlrdata->activecuts!= NULL);
   assert(eventhdlrdata->nactivecuts <= eventhdlrdata->activecutssize);
   assert(eventhdlrdata->nactivecuts >= 0);

   if( eventhdlrdata->activecutssize < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(masterscip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(masterscip, &(eventhdlrdata->activecuts), eventhdlrdata->activecutssize,
                                             newmaxcuts) );
      eventhdlrdata->activecutssize = newmaxcuts;
   }

   assert(eventhdlrdata->activecutssize >= size);

   return SCIP_OKAY;
}

/** re-inserts a global cut (in case it was re-added to the separation storage) to generated cuts */
static
SCIP_RETCODE reinsertGlobalMasterSepaCut(
   SCIP*                   masterscip,           /**< SCIP data structure */
   GCG_MASTERSEPACUT*      mastersepacut,        /**< global master separator cut */
   SCIP_EVENTHDLRDATA*     eventhdlrdata         /**< event handler data data structure */
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_ROW* row = NULL;

   assert(masterscip != NULL);
   assert(mastersepacut != NULL);
   assert(eventhdlrdata != NULL);

   mastercutdata = GCGmastersepacutGetMasterCutData(mastersepacut);
   assert(mastercutdata != NULL);
   SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
   assert(!SCIProwIsLocal(row));

   SCIPdebugMessage("re-add global cuts: row %s is added to generated guts\n", SCIProwGetName(row));
   SCIP_CALL( ensureGeneratedSize(masterscip, eventhdlrdata, eventhdlrdata->ngeneratedcuts + 1) );
   eventhdlrdata->generatedcuts[eventhdlrdata->ngeneratedcuts] = mastersepacut;
   SCIP_CALL( GCGcaptureMasterSepaCut(eventhdlrdata->generatedcuts[eventhdlrdata->ngeneratedcuts]) );
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedmap, row, eventhdlrdata->ngeneratedcuts) );
   (eventhdlrdata->ngeneratedcuts)++;

   return SCIP_OKAY;
}

/**< transfers cut from generated to active upon its addition to the LP */
static
SCIP_RETCODE eventRowAddedToLP(
   SCIP*                   scip,             /**< SCIP data structure */
   SCIP_EVENTHDLRDATA*     eventhdlrdata,    /**< data of eventhandler */
   SCIP_EVENT*             event             /**< row added to LP event */
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   GCG_MASTERSEPACUT* generatedcut;
   SCIP_ROW* mastercutrow = NULL;
   SCIP_SEPA* sepa;
   SCIP_ROW* row;
   int sepaidx;
   int generatedidx;

   assert(scip != NULL);
   assert(eventhdlrdata != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWADDEDLP);
   row = SCIPeventGetRow(event);
   SCIPinfoMessage(scip, NULL, "activate row %s\n", SCIProwGetName(row));

   /* row is added when LP is already constructed --> row is newly generated cut (or re-added global cut)*/
   if( SCIPisLPConstructed(scip) )
   {
      //row = SCIPeventGetRow(event);
      sepa = SCIProwGetOriginSepa(row);

      /* if row was not generated by separator: nothing to do */
      if( sepa == NULL )
      {
         SCIPdebugMessage("row added event: cut was not generated by separator\n");
         return SCIP_OKAY;
      }

      generatedidx = SCIPhashmapGetImageInt(eventhdlrdata->rowxgeneratedmap, row);
      if( generatedidx != INT_MAX )
      {
         SCIPdebugMessage("row added event: row %s is added to active cuts of separator %s (%i) at index %i\n",
                          SCIProwGetName(row), SCIPsepaGetName(sepa), sepaidx, eventhdlrdata->nactivecuts);
         SCIPinfoMessage(scip, NULL, "add row %s at node %lli of type %i\n", SCIProwGetName(row), SCIPnodeGetNumber(SCIPgetCurrentNode(scip)),
                         SCIPnodeGetType(SCIPgetCurrentNode(scip)));
         SCIPprintRow(scip, row, NULL);
         /* transfer cut from generated to active */
         generatedcut = eventhdlrdata->generatedcuts[generatedidx];
         mastercutdata = GCGmastersepacutGetMasterCutData(generatedcut);
         assert(mastercutdata != NULL);
         SCIP_CALL( GCGmastercutGetRow(mastercutdata, &mastercutrow) );
         assert(mastercutrow == row);
         SCIP_CALL( ensureActiveSize(scip, eventhdlrdata, eventhdlrdata->nactivecuts + 1) );

         /* cut is newly generated (not re-added global cut): set its initial variable history */
         if( GCGmastersepacutGetVarHistory(generatedcut) == NULL )
         {
            SCIP_CALL( GCGmastersepacutSetVarHistory(scip, &generatedcut) );
         }

         eventhdlrdata->activecuts[eventhdlrdata->nactivecuts] = generatedcut;
         SCIP_CALL( GCGcaptureMasterSepaCut(eventhdlrdata->activecuts[eventhdlrdata->nactivecuts]) );
         (eventhdlrdata->nactivecuts)++;
      }
   }

   return SCIP_OKAY;
}



/*
 * Callback methods of event handler
 */


/** destructor of event handler to free user data (called when SCIP is exiting) */
static
SCIP_DECL_EVENTFREE(eventFreeMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIPdebugMessage("event free: free hashmaps\n");
   SCIPhashmapFree(&(eventhdlrdata->rowxgeneratedmap));

   SCIPdebugMessage("event free: free event handler data\n");
   SCIPfreeBlockMemory(scip, &eventhdlrdata);

   return SCIP_OKAY;
}

static
SCIP_DECL_EVENTEXIT(eventExitMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* notify SCIP that your event handler wants to drop the event type row added to lp and node deleted found */
   SCIP_CALL( SCIPdropEvent(scip, SCIP_EVENTTYPE_ROWADDEDLP, eventhdlr, NULL, -1) );

   /* free all the arrays */
   SCIPdebugMessage("event free: free mem (%i) for activecuts\n", eventhdlrdata->activecutssize);
   SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->activecuts), eventhdlrdata->activecutssize);
   SCIPdebugMessage("event free: free mem (%i) for generatedcuts\n", eventhdlrdata->generatedcutssize);
   SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->generatedcuts), eventhdlrdata->generatedcutssize);

   eventhdlrdata->nactivecuts = 0;
   eventhdlrdata->ngeneratedcuts = 0;
   eventhdlrdata->generatedcutssize = 0;
   eventhdlrdata->activecutssize = 0;

   return SCIP_OKAY;
}

/** initialization method of event handler (called after problem was transformed) */
static
SCIP_DECL_EVENTINIT(eventInitMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int initialsize;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* initialize event handler data */
   SCIPdebugMessage("event init: alloc mem for active cuts and generated cuts\n");
   initialsize = SCIPcalcMemGrowSize(scip, STARTMAXCUTS);
   SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->activecuts), initialsize) );
   SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts), initialsize) );
   eventhdlrdata->nactivecuts = 0;
   eventhdlrdata->ngeneratedcuts = 0;
   eventhdlrdata->activecutssize = initialsize;
   eventhdlrdata->generatedcutssize = initialsize;

   /* notify SCIP that event handler wants to react on the event types row added to LP and node deleted */
   SCIP_CALL( SCIPcatchEvent(scip, SCIP_EVENTTYPE_ROWADDEDLP, eventhdlr, NULL, NULL) );

   return SCIP_OKAY;
}

/** deinitialization method of event handler (called before transformed problem is freed)
 * - clean up branch-and-bound specific data */
static
SCIP_DECL_EVENTEXITSOL(eventExitSolMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int j;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);


   /* release all the remaining cuts from generated cuts and active cuts */
   SCIPdebugMessage("event exit sol: release remaining %i cuts in generatedcuts\n", eventhdlrdata->ngeneratedcuts);
   for( j = 0; j < eventhdlrdata->ngeneratedcuts; j++ )
   {
      assert(eventhdlrdata->generatedcuts[j] != NULL);
      SCIP_CALL( GCGreleaseMasterSepaCut(scip, &(eventhdlrdata->generatedcuts[j])) );
      assert(eventhdlrdata->generatedcuts[j] == NULL);
   }
   eventhdlrdata->ngeneratedcuts = 0;

   SCIPdebugMessage("event exit sol: release remaining %i cuts in activecuts\n", eventhdlrdata->nactivecuts);
   for( j = 0; j < eventhdlrdata->nactivecuts; j++ )
   {
      assert(eventhdlrdata->activecuts[j] != NULL);
      SCIP_CALL( GCGreleaseMasterSepaCut(scip, &(eventhdlrdata->activecuts[j])) );
      assert(eventhdlrdata->activecuts[j] == NULL);
   }
   eventhdlrdata->nactivecuts = 0;

   SCIPdebugMessage("event exit sol: clear hashmap\n");
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedmap);

   return SCIP_OKAY;
}

/** main execution method of event handler */
static
SCIP_DECL_EVENTEXEC(eventExecEvent)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWADDEDLP);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert( eventhdlrdata != NULL );

   switch( SCIPeventGetType(event) )
   {
      case SCIP_EVENTTYPE_ROWADDEDLP:
         SCIP_CALL( eventRowAddedToLP(scip, eventhdlrdata, event) );
         break;
      default:
         SCIPerrorMessage("Encountered Event not listened to.\n");
         return SCIP_ERROR;
   }

   return SCIP_OKAY;
}

/** creates event handler for row added to LP and node deleted event */
SCIP_RETCODE SCIPincludeEventHdlrSepaCuts(
   SCIP*                 scip                /**< SCIP data structure */
   )
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_EVENTHDLR* eventhdlr;

   /* create event handler data */
   SCIPdebugMessage("include: alloc mem for eventhandler data\n");
   SCIP_CALL( SCIPallocBlockMemory(scip, &eventhdlrdata) );
   assert(eventhdlrdata != NULL);
   SCIPdebugMessage("include: create hashmaps and set nsepas to 0\n");
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->rowxgeneratedmap), SCIPblkmem(scip), STARTMAXCUTS) );

   eventhdlr = NULL;
   SCIP_CALL( SCIPincludeEventhdlrBasic(scip, &eventhdlr, EVENTHDLR_NAME, EVENTHDLR_DESC,
         eventExecEvent, eventhdlrdata) );
   assert(eventhdlr != NULL);

   /* set non fundamental callbacks via setter functions */
   SCIP_CALL( SCIPsetEventhdlrInit(scip, eventhdlr, eventInitMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrExitsol(scip, eventhdlr, eventExitSolMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrExit(scip, eventhdlr, eventExitMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrFree(scip, eventhdlr, eventFreeMastercutUpdate) );

   return SCIP_OKAY;
}


/** adds a new cut to generated cuts */
SCIP_RETCODE GCGaddCutToGeneratedCuts(
   SCIP*                masterscip,       /**< SCIP data structure */
   GCG_MASTERSEPACUT*   mastersepacut     /**< master separator data */
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row = NULL;

   assert(mastersepacut != NULL);
   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   mastercutdata = GCGmastersepacutGetMasterCutData(mastersepacut);
   assert(mastercutdata != NULL);

   SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
   assert(row != NULL);

   SCIP_CALL( ensureGeneratedSize(masterscip, eventhdlrdata, eventhdlrdata->ngeneratedcuts + 1) );
   eventhdlrdata->generatedcuts[eventhdlrdata->ngeneratedcuts] = mastersepacut;
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedmap, row, eventhdlrdata->ngeneratedcuts) );
   (eventhdlrdata->ngeneratedcuts)++;

   return SCIP_OKAY;
}

/** remove all cuts in generated cuts and release them */
SCIP_RETCODE GCGclearGeneratedCuts(
   SCIP*    masterscip          /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   //SCIPinfoMessage(masterscip, NULL, "clear generated cuts\n");
   SCIPdebugMessage("clear %i generated cuts \n", eventhdlrdata->ngeneratedcuts);
   for( j = 0; j < eventhdlrdata->ngeneratedcuts; j++ )
   {
      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->generatedcuts[j])) );
   }
   eventhdlrdata->ngeneratedcuts = 0;

   /* clear corresponding map */
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedmap);

   return SCIP_OKAY;
}

/** remove all cuts in generated cuts and release them */
SCIP_RETCODE GCGclearGeneratedCuts_alt(
   SCIP*    masterscip,          /**< SCIP data structure */
   SCIP_EVENTHDLR* eventhdlr
)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   //SCIPinfoMessage(masterscip, NULL, "clear generated cuts\n");
   SCIPdebugMessage("clear %i generated cuts \n", eventhdlrdata->ngeneratedcuts);
   for( j = 0; j < eventhdlrdata->ngeneratedcuts; j++ )
   {
      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->generatedcuts[j])) );
   }
   eventhdlrdata->ngeneratedcuts = 0;

   /* clear corresponding map */
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedmap);

   return SCIP_OKAY;
}

/** removes new cuts from active cuts which are not in LP and releases them */
SCIP_RETCODE GCGremoveNewInactiveRows(
   SCIP*       masterscip,     /**< SCIP data structure */
   int         startidx        /**< indicate the first new cut  */
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   //SCIPinfoMessage(masterscip, NULL, "remove new inactive\n");
   for( j = eventhdlrdata->nactivecuts - 1; j >= startidx; --j )
   {
      mastercutdata = GCGmastersepacutGetMasterCutData(eventhdlrdata->activecuts[j]);
      assert(mastercutdata != NULL);
      row = NULL;
      SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
      assert(row != NULL);

      /* rows still in LP remain relevant and therefore stay in active cuts */
      if( SCIProwIsInLP(row) )
         continue;

      /* cut was created and removed at same node: can be removed from active cuts and released */
      SCIPdebugMessage("remove new inactive rows: remove row %s and free data\n", SCIProwGetName(row));
      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[j])) );
      assert(eventhdlrdata->activecuts[j] == NULL);
      (eventhdlrdata->nactivecuts)--;
      eventhdlrdata->activecuts[j] = eventhdlrdata->activecuts[eventhdlrdata->nactivecuts];
   }

   return SCIP_OKAY;
}

/** removes new cuts from active cuts which are not in LP and releases them */
SCIP_RETCODE GCGremoveNewInactiveRows_alt(
   SCIP*       masterscip,     /**< SCIP data structure */
   int         startidx,        /**< indicate the first new cut  */
   SCIP_EVENTHDLR* eventhdlr
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   //SCIPinfoMessage(masterscip, NULL, "remove new inactive\n");
   for( j = eventhdlrdata->nactivecuts - 1; j >= startidx; --j )
   {
      mastercutdata = GCGmastersepacutGetMasterCutData(eventhdlrdata->activecuts[j]);
      assert(mastercutdata != NULL);
      row = NULL;
      SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
      assert(row != NULL);

      /* rows still in LP remain relevant and therefore stay in active cuts */
      if( SCIProwIsInLP(row) )
         continue;

      /* cut was created and removed at same node: can be removed from active cuts and released */
      SCIPdebugMessage("remove new inactive rows: remove row %s and free data\n", SCIProwGetName(row));
      SCIPinfoMessage(masterscip, NULL, "discard row %s\n", SCIProwGetName(row));
      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[j])) );
      assert(eventhdlrdata->activecuts[j] == NULL);
      (eventhdlrdata->nactivecuts)--;
      eventhdlrdata->activecuts[j] = eventhdlrdata->activecuts[eventhdlrdata->nactivecuts];
   }

   return SCIP_OKAY;
}

/** removes all cuts after given index from active cuts */
SCIP_RETCODE GCGshrinkActiveCuts(
   SCIP*    masterscip,        /**< SCIP data structure */
   int      newnrows           /**< index to which active cuts should be shrunk to */
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   int j;
   //SCIPinfoMessage(masterscip, NULL, "shrink cuts\n");
   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   if( eventhdlrdata->nactivecuts == 0 )
      return SCIP_OKAY;

   assert(eventhdlrdata->nactivecuts >= newnrows);

   /* release all cuts added to active cuts after newnrows */
   for( j = eventhdlrdata->nactivecuts - 1; j >= newnrows; --j )
   {
      SCIP_ROW* row = NULL;

      mastercutdata = GCGmastersepacutGetMasterCutData(eventhdlrdata->activecuts[j]);
      assert(mastercutdata != NULL);
      SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
      assert(row != NULL);

      /* global cuts with age zero are added to the separation storage before initial LP is constructed
       * --> these cuts will be re-added to the next LP */
      if( masterscip->tree->correctlpdepth != -1 && !SCIProwIsLocal(row) && SCIProwGetAge(row) == 0 )
      {
         SCIP_CALL( reinsertGlobalMasterSepaCut(masterscip, eventhdlrdata->activecuts[j], eventhdlrdata) );
      }

      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[j])) );
   }
   eventhdlrdata->nactivecuts = newnrows;

   return SCIP_OKAY;
}

/** removes all cuts after given index from active cuts */
SCIP_RETCODE GCGshrinkActiveCuts_alt(
   SCIP*    masterscip,        /**< SCIP data structure */
   int      newnrows,           /**< index to which active cuts should be shrunk to */
   SCIP_EVENTHDLR* eventhdlr
)
{
   GCG_MASTERCUTDATA* mastercutdata;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   int j;
   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   if( eventhdlrdata->nactivecuts == 0 )
      return SCIP_OKAY;

   assert(eventhdlrdata->nactivecuts >= newnrows);

   /* release all cuts added to active cuts after newnrows */
   for( j = eventhdlrdata->nactivecuts - 1; j >= newnrows; --j )
   {
      SCIP_ROW* row = NULL;

      mastercutdata = GCGmastersepacutGetMasterCutData(eventhdlrdata->activecuts[j]);
      assert(mastercutdata != NULL);
      SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
      assert(row != NULL);
      SCIPinfoMessage(masterscip, NULL, "deactivate %s\n", SCIProwGetName(row));

      /* global cuts with age zero are added to the separation storage before initial LP is constructed
       * --> these cuts will be re-added to the next LP */
      if( masterscip->tree->correctlpdepth != -1 && !SCIProwIsLocal(row) && SCIProwGetAge(row) == 0 )
      {
         SCIP_CALL( reinsertGlobalMasterSepaCut(masterscip, eventhdlrdata->activecuts[j], eventhdlrdata) );
      }

      SCIP_CALL( GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[j])) );
   }
   eventhdlrdata->nactivecuts = newnrows;

   return SCIP_OKAY;
}

/** returns active master separator cuts */
GCG_MASTERSEPACUT** GCGgetActiveCuts(
   SCIP*          masterscip     /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->activecuts;
}

/** returns active master separator cuts */
GCG_MASTERSEPACUT** GCGgetActiveCuts_alt(
   SCIP*          masterscip,     /**< SCIP data structure */
   SCIP_EVENTHDLR* eventhdlr
)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->activecuts;
}

/** return number of active master separator cuts */
int GCGgetNActiveCuts(
   SCIP*       masterscip     /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->nactivecuts;
}

/** return number of active master separator cuts */
int GCGgetNActiveCuts_alt(
   SCIP*       masterscip,     /**< SCIP data structure */
   SCIP_EVENTHDLR* eventhdlr
)
{

   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->nactivecuts;
}

/** adds a cut generated by a master separator to active cuts */
SCIP_RETCODE GCGaddCutActiveCuts(
   SCIP*                masterscip,      /**< SCIP data structure */
   GCG_MASTERSEPACUT*   mastersepacut    /**< master separator cut */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( ensureActiveSize(masterscip, eventhdlrdata, eventhdlrdata->nactivecuts + 1) );
   SCIPinfoMessage(masterscip, NULL, "activate cut\n");
   eventhdlrdata->activecuts[eventhdlrdata->nactivecuts] = mastersepacut;
   SCIP_CALL( GCGcaptureMasterSepaCut(mastersepacut) );
   (eventhdlrdata->nactivecuts)++;

   return SCIP_OKAY;
}

/** adds a cut generated by a master separator to active cuts */
SCIP_RETCODE GCGaddCutActiveCuts_alt(
   SCIP*                masterscip,       /**< SCIP data structure */
   GCG_MASTERSEPACUT*   mastersepacut,    /**< master separator cut */
   SCIP_EVENTHDLR*      eventhdlr         /**< eventhandler*/
)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row = NULL;
   GCG_MASTERCUTDATA* masterdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( ensureActiveSize(masterscip, eventhdlrdata, eventhdlrdata->nactivecuts + 1) );

   eventhdlrdata->activecuts[eventhdlrdata->nactivecuts] = mastersepacut;
   SCIP_CALL( GCGcaptureMasterSepaCut(mastersepacut) );
   masterdata = GCGmastersepacutGetMasterCutData(mastersepacut);
   SCIP_CALL( GCGmastercutGetRow(masterdata, &row) );
   SCIPinfoMessage(masterscip, NULL, "activate cut %s\n", SCIProwGetName(row));
   (eventhdlrdata->nactivecuts)++;

   return SCIP_OKAY;
}