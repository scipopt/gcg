/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*  Copyright (c) 2002-2023 Zuse Institute Berlin (ZIB)                      */
/*                                                                           */
/*  Licensed under the Apache License, Version 2.0 (the "License");          */
/*  you may not use this file except in compliance with the License.         */
/*  You may obtain a copy of the License at                                  */
/*                                                                           */
/*      http://www.apache.org/licenses/LICENSE-2.0                           */
/*                                                                           */
/*  Unless required by applicable law or agreed to in writing, software      */
/*  distributed under the License is distributed on an "AS IS" BASIS,        */
/*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*  See the License for the specific language governing permissions and      */
/*  limitations under the License.                                           */
/*                                                                           */
/*  You should have received a copy of the Apache-2.0 license                */
/*  along with SCIP; see the file LICENSE. If not visit scipopt.org.         */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file        event_sepacuts.c
 * @ingroup     DEFPLUGINS_EVENT
 * @brief       eventhdlr for xyz event
 * @author      Chantal Reinartz Groba
 */

/*--+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/
#define SCIP_DEBUG

#include <scip/pub_tree.h>
#include <scip/scip_mem.h>
#include <scip/struct_scip.h>
#include <scip/struct_tree.h>
#include <scip/type_event.h>

#include "cons_masterbranch.h"
#include "event_sepacuts.h"
#include "gcg.h"
#include "mastercutdata.h"
#include "misc_varhistory.h"
#include "pricer_gcg.h"
#include "struct_sepagcg.h"
#include "type_sepagcg.h"


#define EVENTHDLR_NAME         "sepacuts"
#define EVENTHDLR_DESC         "event handler for keeping master cuts generated by a separator up-to-date"
#define STARTMAXCUTS            50

/*
 * Data structures
 */

/* TODO: fill in the necessary event handler data */

/** event handler data */
struct SCIP_EventhdlrData
{
   GCG_MASTERSEPACUT***       generatedcuts;          /**< arrays of newly generated cuts from each gcg separator */
   GCG_MASTERSEPACUT***       activecuts;             /**< arrays of active cuts from each gcg separator */
   SCIP_HASHMAP*              rowxgeneratedmap;       /**< maps a row to the index of its mastersepacut in generatedcuts */
   SCIP_HASHMAP*              scipsepaxgcgsepamap;    /**< maps a scip sepa to the index of its corresponding gcg separator */
   int*                       nactivecuts;            /**< number of active cuts for each gcg separator */
   int*                       ngeneratedcuts;         /**< number of newly generated cuts for each gcg separator */
   int*                       activecutssize;         /**< size of memory allocated in active cuts for each gcg separator */
   int*                       generatedcutssize;      /**< size of memory allocated in generated cuts for each gcg separator */
   int                        nsepas;                 /**< number of gcg separators */
};
/*
 * Local methods
 */
/** creates and captures a master separator cut */
static
SCIP_RETCODE createMasterSepaCut(
   SCIP* masterscip,                      /**< SCIP data structure */
   GCG_MASTERSEPACUT** mastersepacut,     /**< pointer to store master separator cut */
   GCG_MASTERCUTDATA* mastercutdata       /**< data associated with the cut */
   )
{
   assert(masterscip != NULL);
   assert(mastercutdata != NULL);
   assert(mastersepacut != NULL);
   assert(GCGisMaster(masterscip));

   SCIP_CALL( SCIPallocBlockMemory(masterscip, mastersepacut) );
   (*mastersepacut)->mastercutdata = mastercutdata;
   (*mastersepacut)->nuses = 0;
   (*mastersepacut)->knownvarhistory = NULL; // initially NULL, until row is added to LP for first time
   (*mastersepacut)->weights = NULL;
   (*mastersepacut)->conssindices = NULL;
   (*mastersepacut)->n = 0;
   SCIP_CALL(GCGcaptureMasterSepaCut(*mastersepacut) );

   return SCIP_OKAY;
}


/** creates and captures a subset row cut */
static
SCIP_RETCODE createMasterSubsetrowSepaCut(
   SCIP*                masterscip,            /**< SCIP data structure */
   GCG_MASTERSEPACUT**  mastersepacut,         /**< pointer to store master separator cut */
   GCG_MASTERCUTDATA*   mastercutdata,         /**< data associated with the cut */
   SCIP_Real*           weights,               /**< weights which were used to create the cut */
   int*                 indices,               /**< indices of constraints used to create the cut */
   int                  n                      /**< number of constraints used to create the cut */
)
{
   int i;
   assert(masterscip != NULL);
   assert(mastercutdata != NULL);
   assert(mastersepacut != NULL);
   assert(GCGisMaster(masterscip));

   SCIP_CALL( SCIPallocBlockMemory(masterscip, mastersepacut) );
   (*mastersepacut)->mastercutdata = mastercutdata;
   (*mastersepacut)->nuses = 0;
   (*mastersepacut)->knownvarhistory = NULL; // initially NULL, until row is added to LP for first time
   (*mastersepacut)->weights = NULL;
   (*mastersepacut)->conssindices = NULL;
   (*mastersepacut)->n = 0;

   if( n > 0 )
   {
      SCIPallocBlockMemoryArray(masterscip, &((*mastersepacut)->weights), n);
      SCIPallocBlockMemoryArray(masterscip, &((*mastersepacut)->conssindices), n);
      (*mastersepacut)->n = n;

      for( i = 0; i < n; i++ )
      {
         (*mastersepacut)->weights[i] = weights[i];
         (*mastersepacut)->conssindices[i] = indices[i];
      }
   }

   SCIP_CALL(GCGcaptureMasterSepaCut(*mastersepacut) );

   return SCIP_OKAY;
}

/** frees master separator cut */
static
SCIP_RETCODE freeMasterSepaCut(
   SCIP* masterscip,                    /**< SCIP data structure */
   GCG_MASTERSEPACUT** mastersepacut    /**< pointer to master sepa cut */
   )
{
   SCIP_ROW* row;
   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(mastersepacut != NULL);
   assert(*mastersepacut != NULL);

   if( (*mastersepacut)->knownvarhistory != NULL )
   {
      SCIPdebugMessage("free mastersepacut: var history is freed\n");
      SCIP_CALL( GCGvarhistoryFreeReference(masterscip, &((*mastersepacut)->knownvarhistory)) );
   }
   if( (*mastersepacut)->n > 0 )
   {
      SCIPfreeBlockMemoryArrayNull(masterscip, &((*mastersepacut)->conssindices), (*mastersepacut)->n);
      SCIPfreeBlockMemoryArrayNull(masterscip, &((*mastersepacut)->weights), (*mastersepacut)->n);
      (*mastersepacut)->n = 0;
   }

   SCIP_CALL( GCGmastercutGetRow((*mastersepacut)->mastercutdata, &row) );
   SCIPdebugMessage("free mastersepacut: free cut for row %s\n", SCIProwGetName(row));
   SCIP_CALL( GCGmastercutFreeMaster(masterscip, &((*mastersepacut)->mastercutdata)) );
   SCIPfreeBlockMemory(masterscip, mastersepacut);

   *mastersepacut = NULL;

   return SCIP_OKAY;
}

/** allocates enough memory in generatedcuts for the specified separator */
static
SCIP_RETCODE ensureGeneratedSize(
   SCIP* masterscip,                   /**< SCIP data structure */
   SCIP_EVENTHDLRDATA* eventhdlrdata,  /**< event handler data data structure */
   int sepaidx,                        /**< index of the separator whose array should be increased */
   int size                            /**< new size of array */
)
{
   assert(masterscip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->generatedcuts != NULL);
   assert(eventhdlrdata->generatedcuts[sepaidx] != NULL);
   assert(eventhdlrdata->ngeneratedcuts[sepaidx] <= eventhdlrdata->generatedcutssize[sepaidx]);
   assert(eventhdlrdata->ngeneratedcuts[sepaidx] >= 0);

   if( eventhdlrdata->generatedcutssize[sepaidx] < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(masterscip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(masterscip, &(eventhdlrdata->generatedcuts[sepaidx]), eventhdlrdata->generatedcutssize[sepaidx], newmaxcuts) );
      eventhdlrdata->generatedcutssize[sepaidx] = newmaxcuts;
   }

   assert(eventhdlrdata->generatedcutssize[sepaidx] >= size);

   return SCIP_OKAY;
}

/** allocates enough memory in activecuts for the specified separator */
static
SCIP_RETCODE ensureActiveSize(
   SCIP* masterscip,                   /**< SCIP data structure */
   SCIP_EVENTHDLRDATA* eventhdlrdata,  /**< event handler data data structure */
   int sepaidx,                        /**< index of the separator whose array should be increased */
   int size                            /**< new size of array */
)
{
   assert(masterscip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->activecuts != NULL);
   assert(eventhdlrdata->activecuts[sepaidx] != NULL);
   assert(eventhdlrdata->nactivecuts[sepaidx] <= eventhdlrdata->activecutssize[sepaidx]);
   assert(eventhdlrdata->nactivecuts[sepaidx] >= 0);

   if( eventhdlrdata->activecutssize[sepaidx] < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(masterscip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(masterscip, &(eventhdlrdata->activecuts[sepaidx]), eventhdlrdata->activecutssize[sepaidx], newmaxcuts) );
      eventhdlrdata->activecutssize[sepaidx] = newmaxcuts;
   }

   assert(eventhdlrdata->activecutssize[sepaidx] >= size);

   return SCIP_OKAY;
}

static
SCIP_RETCODE setVarHistory(
   SCIP* scip,
   GCG_MASTERSEPACUT** storedcut
)
{

   assert(scip != NULL);
   assert(storedcut != NULL);
   assert(*storedcut != NULL);
#ifdef SCIP_DEBUG
   SCIP_ROW* row;
   SCIP_CALL( GCGmastercutGetRow((*storedcut)->mastercutdata, &row) );
   SCIPdebugMessage("set var history: set history for row %s\n", SCIProwGetName(row));
#endif

   SCIP_CALL( GCGvarhistoryCopyReference(scip, &((*storedcut)->knownvarhistory), GCGgetCurrentVarhistoryReference(scip)) );
   return SCIP_OKAY;
}

static
SCIP_RETCODE eventRowAddedToLP(
   SCIP* scip,
   SCIP_EVENTHDLRDATA* eventhdlrdata,
   SCIP_EVENT* event
)
{
   GCG_MASTERSEPACUT* storedcut;
   SCIP_ROW* mastercutrow;
   SCIP_ROW* row;
   SCIP_SEPA* sepa;
   int sepaidx;
   int generatedidx;
   int i;

   assert(scip != NULL);
   assert(eventhdlrdata != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWADDEDLP);

   /* row is added when LP is already constructed --> row is newly generated cut */
   if( SCIPisLPConstructed(scip) )
   {
      row = SCIPeventGetRow(event);
      sepa = SCIProwGetOriginSepa(row);

      /* if row was not generated by separator: nothing to do */
      if( sepa == NULL )
      {
         //SCIPdebugMessage("row added event: cut was not generated by separator\n");
         return SCIP_OKAY;
      }

      sepaidx = SCIPhashmapGetImageInt(eventhdlrdata->scipsepaxgcgsepamap, sepa);
      SCIPdebugMessage("row added event: row %s was generated by sepa (%s, %i)\n", SCIProwGetName(row),
                       SCIPsepaGetName(sepa), sepaidx);
      if( SCIPhashmapExists(eventhdlrdata->rowxgeneratedmap, row) )
      {
         /* create corresponding storedcut of new row and add it to active cuts */
         SCIPinfoMessage(scip, NULL, "row added event: row %s is added to active cuts at %i\n", SCIProwGetName(row),
                         eventhdlrdata->nactivecuts[sepaidx]);
         SCIPdebugMessage("row added event: row %s is added to active cuts at %i\n", SCIProwGetName(row),
                          eventhdlrdata->nactivecuts[sepaidx]);
         generatedidx = SCIPhashmapGetImageInt(eventhdlrdata->rowxgeneratedmap, row);
         storedcut = eventhdlrdata->generatedcuts[sepaidx][generatedidx];
         SCIP_CALL( GCGmastercutGetRow(storedcut->mastercutdata, &mastercutrow) );
         assert(mastercutrow == row);
         SCIP_CALL( ensureActiveSize(scip, eventhdlrdata, sepaidx, eventhdlrdata->nactivecuts[sepaidx] + 1) );
         if( storedcut->knownvarhistory == NULL )
            SCIP_CALL( setVarHistory(scip, &storedcut) );
         eventhdlrdata->activecuts[sepaidx][eventhdlrdata->nactivecuts[sepaidx]] = storedcut;
         SCIP_CALL(GCGcaptureMasterSepaCut(eventhdlrdata->activecuts[sepaidx][eventhdlrdata->nactivecuts[sepaidx]]) );
         (eventhdlrdata->nactivecuts[sepaidx])++;
      }
   }
   return SCIP_OKAY;
}

static
SCIP_RETCODE eventNodeDeleted(
   SCIP* scip,
   SCIP_EVENTHDLRDATA* eventhdlrdata,
   SCIP_EVENT* event
)
{
   SCIP_NODE* node;
   SCIP_CONSDATA* consdata;

   assert(scip != NULL);
   assert(eventhdlrdata != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_NODEDELETE);

   node = SCIPeventGetNode(event);

   SCIP_CALL( GCGdeleteNode(scip, node) );

   return SCIP_OKAY;
}


/*
 * Callback methods of event handler
 */


/** destructor of event handler to free user data (called when SCIP is exiting) */
static
SCIP_DECL_EVENTFREE(eventFreeMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;

   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIPdebugMessage("event free: free hashmaps\n");
   SCIPhashmapFree(&(eventhdlrdata->rowxgeneratedmap));
   SCIPhashmapFree(&(eventhdlrdata->scipsepaxgcgsepamap));

   SCIPdebugMessage("event free: free event handler data\n");
   SCIPfreeBlockMemory(scip, &eventhdlrdata);

   return SCIP_OKAY;
}

static
SCIP_DECL_EVENTEXIT(eventExitMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;

   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* free all the arrays */
   if( eventhdlrdata->nsepas > 0)
   {
      SCIPdebugMessage("event free: free mem for (n)activecuts and (n)generatedcuts\n");
      for( i = eventhdlrdata->nsepas - 1; i >= 0 ; i-- )
      {
         SCIPdebugMessage("event free: free mem (%i) for activecuts[%i]\n", eventhdlrdata->activecutssize[i], i);
         SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->activecuts[i]), eventhdlrdata->activecutssize[i]);
         SCIPdebugMessage("event free: free mem (%i) for generatedcuts[%i]\n", eventhdlrdata->generatedcutssize[i], i);
         SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->generatedcuts[i]), eventhdlrdata->generatedcutssize[i]);
      }
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->activecuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->generatedcuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->nactivecuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->ngeneratedcuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->generatedcutssize), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArrayNull(scip, &(eventhdlrdata->activecutssize), eventhdlrdata->nsepas);
   }
   else
   {
      SCIPdebugMessage("event free: no sepas registered: arrays remained NULL --> nothing to free\n");
   }
   eventhdlrdata->nsepas = 0;

   return SCIP_OKAY;
}

/** initialization method of event handler (called after problem was transformed) */
static
SCIP_DECL_EVENTINIT(eventInitMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_SEPA** sepas;
   int initialsize;
   int nsepas;
   int i;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* initialize event handler data:
    * - each separator gets own array of active/all/generated cuts */
   nsepas = GCGrelaxGetNSeparators(scip);
   sepas = GCGrelaxGetSeparators(scip);
   if( nsepas > 0 )
   {
      SCIPdebugMessage("event init: alloc mem for (n)activecuts and (n)generatedcuts\n");
      initialsize = SCIPcalcMemGrowSize(scip, STARTMAXCUTS);
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->activecuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->nactivecuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->ngeneratedcuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->activecutssize), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcutssize), nsepas) );

      for( i = 0; i < nsepas; i++ )
      {
         SCIPdebugMessage("event init: alloc block mem (%i) for sepa %i\n", initialsize, i);
         SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->activecuts[i]), initialsize) );
         SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts[i]), initialsize) );
         eventhdlrdata->nactivecuts[i] = 0;
         eventhdlrdata->ngeneratedcuts[i] = 0;
         eventhdlrdata->generatedcutssize[i] = initialsize;
         eventhdlrdata->activecutssize[i] = initialsize;
         SCIP_CALL( SCIPhashmapInsertInt(eventhdlrdata->scipsepaxgcgsepamap, sepas[i]->separator, i) );
      }
   }
   else
   {
      SCIPdebugMessage("event init: detected no registered separators --> no need to alloc mem for arrays: set to NULL\n");
      eventhdlrdata->activecuts = NULL;
      eventhdlrdata->generatedcuts = NULL;
      eventhdlrdata->nactivecuts = NULL;
      eventhdlrdata->ngeneratedcuts = NULL;
      eventhdlrdata->generatedcutssize = NULL;
      eventhdlrdata->activecutssize = NULL;
   }
   SCIPdebugMessage("event init: set nsepas to %i\n", nsepas);
   eventhdlrdata->nsepas = nsepas;
   /* notify SCIP that event handler wants to react on the event types row added to LP and node deleted */
   SCIP_CALL( SCIPcatchEvent(scip, (SCIP_EVENTTYPE_ROWADDEDLP | SCIP_EVENTTYPE_NODEDELETE), eventhdlr, NULL, NULL) );
   return SCIP_OKAY;
}

/** deinitialization method of event handler (called before transformed problem is freed)
 * - clean up branch-and-bound specific data */
static
SCIP_DECL_EVENTEXITSOL(eventExitSolMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;
   int j;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* notify SCIP that your event handler wants to drop the event type lp solved and solution found */
   SCIP_CALL( SCIPdropEvent(scip, (SCIP_EVENTTYPE_ROWADDEDLP | SCIP_EVENTTYPE_NODEDELETE), eventhdlr, NULL, -1) );

   /* free all the remaining cuts from arrays */
   if( eventhdlrdata->nsepas > 0)
   {
      for( i = eventhdlrdata->nsepas - 1; i >= 0 ; i-- )
      {
         SCIPdebugMessage("event exitsol: release remaining %i cuts in generatedcuts[%i]\n",
                          eventhdlrdata->ngeneratedcuts[i], i);

         for( j = 0; j < eventhdlrdata->ngeneratedcuts[i]; j++ )
         {
            assert(eventhdlrdata->generatedcuts[i][j] != NULL);
            SCIP_CALL( GCGreleaseMasterSepaCut(scip, &(eventhdlrdata->generatedcuts[i][j])) );
            assert(eventhdlrdata->generatedcuts[i][j] == NULL);
         }
         eventhdlrdata->ngeneratedcuts[i] = 0;
         SCIPdebugMessage("event exitsol: release remaining %i cuts in activecuts[%i]\n", eventhdlrdata->nactivecuts[i], i);
         for( j = 0; j < eventhdlrdata->nactivecuts[i]; j++ )
         {
            assert(eventhdlrdata->activecuts[i][j] != NULL);
            SCIP_CALL( GCGreleaseMasterSepaCut(scip, &(eventhdlrdata->activecuts[i][j])) );
            assert(eventhdlrdata->activecuts[i][j] == NULL);
         }
         eventhdlrdata->nactivecuts[i] = 0;
      }
   }
   else
   {
      SCIPdebugMessage("event exitsol: no sepas were registered --> array remained NULL\n");
   }
   SCIPdebugMessage("event exitsol: clear hashmaps\n");
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedmap);
   SCIPhashmapRemoveAll(eventhdlrdata->scipsepaxgcgsepamap);

   return SCIP_OKAY;
}

/** main execution method of event handler */
static
SCIP_DECL_EVENTEXEC(eventExecEvent)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWADDEDLP | SCIPeventGetType(event) == SCIP_EVENTTYPE_NODEDELETE);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert( eventhdlrdata != NULL );

   switch( SCIPeventGetType(event) )
   {
      case SCIP_EVENTTYPE_ROWADDEDLP:
         SCIP_CALL( eventRowAddedToLP(scip, eventhdlrdata, event) );
         break;
      case SCIP_EVENTTYPE_NODEDELETE:
         SCIP_CALL( eventNodeDeleted(scip, eventhdlrdata, event) );
         break;
      default:
         SCIPerrorMessage("Encountered Event not listened to. \n");
         return SCIP_ERROR;
   }

   return SCIP_OKAY;
}

/** creates event handler for xyz event */
SCIP_RETCODE SCIPincludeEventHdlrSepaCuts(
   SCIP*                 scip                /**< SCIP data structure */
   )
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_EVENTHDLR* eventhdlr;

   /* create event handler data */
   SCIPdebugMessage("include: alloc mem for eventhandler data\n");
   SCIP_CALL( SCIPallocBlockMemory(scip, &eventhdlrdata) );
   assert(eventhdlrdata != NULL);
   SCIPdebugMessage("include: create hashmaps and set nsepas to 0\n");
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->rowxgeneratedmap), SCIPblkmem(scip), STARTMAXCUTS) );
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->scipsepaxgcgsepamap), SCIPblkmem(scip), 10) );
   eventhdlrdata->nsepas = 0;

   eventhdlr = NULL;
   SCIP_CALL( SCIPincludeEventhdlrBasic(scip, &eventhdlr, EVENTHDLR_NAME, EVENTHDLR_DESC,
         eventExecEvent, eventhdlrdata) );
   assert(eventhdlr != NULL);

   /* set non fundamental callbacks via setter functions */
   SCIP_CALL( SCIPsetEventhdlrInit(scip, eventhdlr, eventInitMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrExitsol(scip, eventhdlr, eventExitSolMastercutUpdate) );
   SCIP_CALL(SCIPsetEventhdlrExit(scip, eventhdlr, eventExitMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrFree(scip, eventhdlr, eventFreeMastercutUpdate) );

   return SCIP_OKAY;
}

/** increases usage counter of master separator cut */
SCIP_RETCODE GCGcaptureMasterSepaCut(
   GCG_MASTERSEPACUT* mastersepacut   /**< MASTERSEPACUT data structure */
)
{
   SCIP_ROW* row;
   assert(mastersepacut != NULL);
   assert(mastersepacut->nuses >= 0);

   (mastersepacut->nuses)++;
   SCIP_CALL( GCGmastercutGetRow(mastersepacut->mastercutdata, &row) );
   SCIPdebugMessage("capture mastersepacut: row %s now has %i nuses\n", SCIProwGetName(row), mastersepacut->nuses);

   return SCIP_OKAY;
}

/** decreases usage counter of master sepa cut, and frees memory if necessary */
SCIP_RETCODE GCGreleaseMasterSepaCut(
   SCIP* masterscip,                    /**< SCIP data structure */
   GCG_MASTERSEPACUT** mastersepacut    /**< pointer to master sepa cut */
)
{
   SCIP_ROW* row;
   assert(masterscip != NULL);
   assert(mastersepacut != NULL);
   assert(*mastersepacut != NULL);
   assert((*mastersepacut)->nuses >= 0);

   ((*mastersepacut)->nuses)--;
   SCIP_CALL( GCGmastercutGetRow((*mastersepacut)->mastercutdata, &row) );
   SCIPdebugMessage("release mastersepacut: row %s now has %i nuses\n", SCIProwGetName(row), (*mastersepacut)->nuses);

   if((*mastersepacut)->nuses == 0 )
   {
      SCIP_CALL( freeMasterSepaCut(masterscip, mastersepacut) );
   }

   *mastersepacut = NULL;

   return SCIP_OKAY;
}

/** adds a new cut to generatedcut */
SCIP_RETCODE GCGaddCutToGeneratedCutsSepa(
   SCIP*                masterscip,       /**< SCIP data structure */
   GCG_MASTERCUTDATA*   mastercutdata,    /**< mastercut data */
   SCIP_Real*           weights,          /**< weights used to create the cut */
   int*                 conssindices,     /**< indices of constraints used to create the cut */
   int                  n,                /**< number of constraints used to create the cut */
   int                  sepaidx           /**< index of the separator which generated the cut */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_MASTERSEPACUT* mastersepacut;
   SCIP_ROW* row;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(mastercutdata != NULL);

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
   assert(row != NULL);

   SCIP_CALL( ensureGeneratedSize(masterscip, eventhdlrdata, sepaidx, eventhdlrdata->ngeneratedcuts[sepaidx] + 1) );
   SCIP_CALL( createMasterSubsetrowSepaCut(masterscip, &mastersepacut, mastercutdata, weights, conssindices, n) );
   //SCIP_CALL( createMasterSepaCut(masterscip, &mastersepacut, mastercutdata) );
   eventhdlrdata->generatedcuts[sepaidx][eventhdlrdata->ngeneratedcuts[sepaidx]] = mastersepacut;
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedmap, row, eventhdlrdata->ngeneratedcuts[sepaidx]) );
   (eventhdlrdata->ngeneratedcuts[sepaidx])++;

   return SCIP_OKAY;
}

/** re-inserts a global cut (in case it was re-added to the sepastore) */
SCIP_RETCODE GCGreinsertGlobalMasterSepaCut(
   SCIP* masterscip,                   /**< SCIP data structure */
   GCG_MASTERSEPACUT* mastersepacut,   /**< global master sepa cut */
   SCIP_EVENTHDLRDATA* eventhdlrdata,  /**< event handler data data structure */
   int sepaidx                         /**< index of separator which generated the cut */
)
{
   SCIP_ROW* row;

   assert(masterscip != NULL);
   assert(mastersepacut != NULL);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( GCGmastercutGetRow(mastersepacut->mastercutdata, &row) );
   assert(!SCIProwIsLocal(row));
   SCIPdebugMessage("re-add global cuts: row %s is added to generated guts\n", SCIProwGetName(row));
   SCIP_CALL( ensureGeneratedSize(masterscip, eventhdlrdata, sepaidx, eventhdlrdata->ngeneratedcuts[sepaidx] + 1) );
   eventhdlrdata->generatedcuts[sepaidx][eventhdlrdata->ngeneratedcuts[sepaidx]] = mastersepacut;
   SCIP_CALL( GCGcaptureMasterSepaCut(eventhdlrdata->generatedcuts[sepaidx][eventhdlrdata->ngeneratedcuts[sepaidx]]) );
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedmap, row, eventhdlrdata->ngeneratedcuts[sepaidx]) );
   (eventhdlrdata->ngeneratedcuts[sepaidx])++;

   return SCIP_OKAY;
}

/** removes all cuts in generatedcuts and releases them */
SCIP_RETCODE GCGclearGeneratedCuts(
   SCIP* masterscip          /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIPdebugMessage("clear generated cuts\n");

   /* clear out generatedcuts array */
   for( i = 0; i < eventhdlrdata->nsepas; i++ )
   {
      SCIPdebugMessage("clear generated cuts: sepa %i has %i cuts\n", i, eventhdlrdata->ngeneratedcuts[i]);
      for( j = 0; j < eventhdlrdata->ngeneratedcuts[i]; j++ )
      {
         SCIP_CALL(GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->generatedcuts[i][j])) );
      }
      eventhdlrdata->ngeneratedcuts[i] = 0;
   }

   /* clear corresponding map */
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedmap);

   return SCIP_OKAY;
}

/** removes new cuts from activectus which are not in LP and releases them */
SCIP_RETCODE GCGremoveNewInactiveRows(
   SCIP* masterscip,    /**< SCIP data structure */
   int* startidx        /**< indicate the first new cut from each separator */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   int i;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   for( i = 0; i < eventhdlrdata->nsepas; i++ )
   {
      for( j = eventhdlrdata->nactivecuts[i] - 1; j >= startidx[i]; --j )
      {
         SCIP_CALL( GCGmastercutGetRow(eventhdlrdata->activecuts[i][j]->mastercutdata, &row) );

         /* rows still in LP remain relevant */
         if( SCIProwIsInLP(row) )
            continue;

         /* cut was created and removed at same node: can be remove from list and released */
         SCIPdebugMessage("remove new inactive rows: remove row %s and free data\n", SCIProwGetName(row));
         SCIP_CALL(GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[i][j])) );
         assert(eventhdlrdata->activecuts[i][j] == NULL);
         (eventhdlrdata->nactivecuts[i])--;
         eventhdlrdata->activecuts[i][j] = eventhdlrdata->activecuts[i][eventhdlrdata->nactivecuts[i]];
      }
   }
   return SCIP_OKAY;
}

/** removes all cuts after given number of cut from active cuts */
SCIP_RETCODE GCGshrinkActiveCuts(
   SCIP* masterscip,    /**< SCIP data structure */
   int* newnrows        /**< indices to which activecuts should be shrunk to */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   int i;
   int j;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->nsepas > 0);

   for( i = 0; i < eventhdlrdata->nsepas; i++ )
   {
      assert(eventhdlrdata->nactivecuts[i] >= newnrows[i]);
      for( j = eventhdlrdata->nactivecuts[i] - 1; j >= newnrows[i]; --j )
      {
         SCIP_CALL( GCGmastercutGetRow(eventhdlrdata->activecuts[i][j]->mastercutdata, &row) );

         /* global cuts with age zero, are added to the separation storage before initial LP is constructed
          * --> these cuts will be re-added to the next LP */
         if( masterscip->tree->correctlpdepth != -1 && !SCIProwIsLocal(row) && SCIProwGetAge(row) == 0 )
         {
            SCIP_CALL( GCGreinsertGlobalMasterSepaCut(masterscip, eventhdlrdata->activecuts[i][j], eventhdlrdata, i) );
         }

         SCIP_CALL(GCGreleaseMasterSepaCut(masterscip, &(eventhdlrdata->activecuts[i][j])) );
      }
      eventhdlrdata->nactivecuts[i] = newnrows[i];
   }

   return SCIP_OKAY;
}

/** return activecuts for each separator */
GCG_MASTERSEPACUT*** GCGgetActiveCuts(
   SCIP* masterscip     /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->activecuts;
}

/** return number of activecuts for each separator */
int* GCGgetNActiveCuts(
   SCIP* masterscip     /**< SCIP data structure */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   return eventhdlrdata->nactivecuts;
}

/** adds a master sepa cut to activecuts*/
SCIP_RETCODE GCGaddCutActiveCuts(
   SCIP* masterscip,                   /**< SCIP data structure */
   GCG_MASTERSEPACUT* mastersepacut,   /**< master sepa cut */
   int sepaidx                         /**< index of the separator which generated the cut */
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));

   eventhdlr = SCIPfindEventhdlr(masterscip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( ensureActiveSize(masterscip, eventhdlrdata, sepaidx, eventhdlrdata->nactivecuts[sepaidx] + 1) );
   eventhdlrdata->activecuts[sepaidx][eventhdlrdata->nactivecuts[sepaidx]] = mastersepacut;
   SCIP_CALL( GCGcaptureMasterSepaCut(mastersepacut) );
   (eventhdlrdata->nactivecuts[sepaidx])++;

   return SCIP_OKAY;
}

GCG_MASTERCUTDATA* GCGsepamastercutGetMastercutData(
   GCG_MASTERSEPACUT* mastersepacut
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->mastercutdata;
}

SCIP_Real* GCGsepamastercutGetWeights(
   GCG_MASTERSEPACUT* mastersepacut
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->weights;
}

int* GCGsepamastercutGetConssIndices(
   GCG_MASTERSEPACUT* mastersepacut
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->conssindices;
}

int GCGsepamastercutGetNWeights(
   GCG_MASTERSEPACUT* mastersepacut
   )
{
   assert(mastersepacut != NULL);

   return  mastersepacut->n;
}
