/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*  Copyright (c) 2002-2023 Zuse Institute Berlin (ZIB)                      */
/*                                                                           */
/*  Licensed under the Apache License, Version 2.0 (the "License");          */
/*  you may not use this file except in compliance with the License.         */
/*  You may obtain a copy of the License at                                  */
/*                                                                           */
/*      http://www.apache.org/licenses/LICENSE-2.0                           */
/*                                                                           */
/*  Unless required by applicable law or agreed to in writing, software      */
/*  distributed under the License is distributed on an "AS IS" BASIS,        */
/*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*  See the License for the specific language governing permissions and      */
/*  limitations under the License.                                           */
/*                                                                           */
/*  You should have received a copy of the Apache-2.0 license                */
/*  along with SCIP; see the file LICENSE. If not visit scipopt.org.         */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file        event_sepacuts.c
 * @ingroup     DEFPLUGINS_EVENT
 * @brief       eventhdlr for xyz event
 * @author      Chantal Reinartz Groba
 */

/*--+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/
#define SCIP_DEBUG
//#include "scip/tree.h"
#include <scip/pub_tree.h>
#include "event_sepacuts.h"
#include "type_mastercutdata.h"
#include "misc_varhistory.h"
#include "type_sepagcg.h"
#include "gcg.h"
#include "mastercutdata.h"
#include "pricer_gcg.h"
#include "scip/scip_mem.h"
#include "scip/struct_scip.h"
#include "struct_sepagcg.h"
#include "scip/struct_tree.h"

#define EVENTHDLR_NAME         "sepacuts"
#define EVENTHDLR_DESC         "event handler for keeping master cuts generated by a separator up-to-date"
#define STARTMAXCUTS            50

/*
 * Data structures
 */

/* TODO: fill in the necessary event handler data */



struct GCG_StoredCut
{
   GCG_MASTERCUTDATA*      mastercutdata;          /**< mastercutdata */
   GCG_VARHISTORY*         knownvarhistory;        /**< pointer to the history of priced variables */
   long long int*          sourcenode;             /**< nodes at which the row could be stored */
   int                     nsourcenodes;           /**< number of nodes at which the row could be stored */
   int                     sourcenodessize;
};

typedef struct GCG_StoredCut GCG_STOREDCUT;


/** event handler data */
struct SCIP_EventhdlrData
{
   GCG_MASTERCUTDATA***       generatedcuts;          /**< arrays of newly generated separator cuts for each separator */
   GCG_STOREDCUT***           allcuts;                /**< arrays of all cuts which are in/could be re-added to the LP for each separator */
   SCIP_HASHMAP*              rowxallidx;             /**< maps a row to its index in the inactive array */
   SCIP_HASHMAP*              rowxgeneratedidx;       /**< maps a row to its index in the generated array */
   SCIP_HASHMAP*              sepaxidx;
   int*                       nallcuts;               /**< number of inactive cuts */
   int*                       ngeneratecuts;          /**< number of newly generated cuts */
   int*                       allcutssize;            /**< size of memory allocated for inactive cuts */
   int*                       generatecutssize;       /**< size of memory allocated for generated cuts */
   int                        nsepas;
};
/*
 * Local methods
 */

/* put your local methods here, and declare them static */

SCIP_RETCODE createStoredCut(
   SCIP* scip,
   GCG_STOREDCUT** storedcut,
   GCG_MASTERCUTDATA* mastercutdata
   )
{
   assert(scip != NULL);
   assert(mastercutdata != NULL);
   assert(storedcut != NULL);
   assert(*storedcut != NULL);

   SCIP_CALL( SCIPallocBlockMemory(scip, storedcut) );
   (*storedcut)->mastercutdata = mastercutdata;
   (*storedcut)->knownvarhistory = NULL;
   SCIP_CALL( GCGvarhistoryCopyReference(scip, &((*storedcut)->knownvarhistory), GCGgetCurrentVarhistoryReference(scip)) );
   (*storedcut)->sourcenodessize = SCIPcalcMemGrowSize(scip, 1);
   SCIP_CALL(SCIPallocBlockMemoryArray(scip, &((*storedcut)->sourcenode), (*storedcut)->sourcenodessize) );
   (*storedcut)->sourcenode[0] = SCIPnodeGetNumber(SCIPgetFocusNode(scip));
   (*storedcut)->nsourcenodes = 1;

   return SCIP_OKAY;
}

SCIP_RETCODE freeStoredCut(
   SCIP* scip,
   GCG_STOREDCUT** storedcut
   )
{
   assert(scip != NULL);
   assert(GCGisOriginal(scip));
   assert(storedcut != NULL);
   assert(*storedcut != NULL);

   SCIP_CALL( GCGvarhistoryFreeReference(scip, &((*storedcut)->knownvarhistory)) );
   SCIPfreeBlockMemoryArray(scip, &((*storedcut)->sourcenode), (*storedcut)->nsourcenodes);
   GCGmastercutFree(scip, &((*storedcut)->mastercutdata));
   SCIPfreeBlockMemory(scip, storedcut);

   *storedcut = NULL;

   return SCIP_OKAY;
}


SCIP_RETCODE ensureGeneratedSize(
   SCIP* scip,
   SCIP_EVENTHDLRDATA* eventhdlrdata,
   int sepaidx,
   int size
)
{
   assert(scip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->generatedcuts != NULL);
   assert(eventhdlrdata->generatedcuts[sepaidx] != NULL);
   assert(eventhdlrdata->ngeneratecuts[sepaidx] <= eventhdlrdata->generatecutssize[sepaidx]);
   assert(eventhdlrdata->ngeneratecuts[sepaidx] >= 0);

   if( eventhdlrdata->generatecutssize[sepaidx] < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(scip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts[sepaidx]), eventhdlrdata->generatecutssize[sepaidx], newmaxcuts) );
      eventhdlrdata->generatecutssize[sepaidx] = newmaxcuts;
   }

   assert(eventhdlrdata->generatecutssize[sepaidx] >= size);

   return SCIP_OKAY;
}

SCIP_RETCODE ensureAllSize(
   SCIP* scip,
   SCIP_EVENTHDLRDATA* eventhdlrdata,
   int sepaidx,
   int size
)
{
   assert(scip != NULL);
   assert(eventhdlrdata != NULL);
   assert(eventhdlrdata->allcuts != NULL);
   assert(eventhdlrdata->allcuts[sepaidx] != NULL);
   assert(eventhdlrdata->nallcuts[sepaidx] <= eventhdlrdata->allcutssize[sepaidx]);
   assert(eventhdlrdata->nallcuts[sepaidx] >= 0);

   if( eventhdlrdata->allcutssize[sepaidx] < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(scip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(scip, &(eventhdlrdata->allcuts[sepaidx]), eventhdlrdata->allcutssize[sepaidx], newmaxcuts) );
      eventhdlrdata->allcutssize[sepaidx] = newmaxcuts;
   }

   assert(eventhdlrdata->allcutssize[sepaidx] >= size);

   return SCIP_OKAY;
}

SCIP_RETCODE ensureSourceNodesSize(
   SCIP* scip,
   GCG_STOREDCUT* storedcut,
   int size
   )
{
   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(storedcut->sourcenode != NULL);
   assert(storedcut->nsourcenodes >= 0);
   assert(storedcut->nsourcenodes <= storedcut->sourcenodessize);

   if( storedcut->sourcenodessize < size )
   {
      int newmaxcuts = SCIPcalcMemGrowSize(scip, size);
      SCIP_CALL( SCIPreallocBlockMemoryArray(scip, &(storedcut->sourcenode), storedcut->sourcenodessize, newmaxcuts) );
      storedcut->sourcenodessize = newmaxcuts;
   }

   assert(storedcut->sourcenodessize >= size);
   return SCIP_OKAY;
}

SCIP_RETCODE addCutToGeneratedCutsSepa(
   SCIP* scip,
   GCG_MASTERCUTDATA* mastercutdata,
   int sepaidx
   )
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(mastercutdata != NULL);

   eventhdlr = SCIPfindEventhdlr(scip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
   assert(row != NULL);

   SCIP_CALL( ensureGeneratedSize(scip, eventhdlrdata, sepaidx, eventhdlrdata->ngeneratecuts[sepaidx] + 1) );
   eventhdlrdata->generatedcuts[sepaidx][eventhdlrdata->ngeneratecuts[sepaidx]] = mastercutdata;
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedidx, row, eventhdlrdata->ngeneratecuts[sepaidx]) );
   (eventhdlrdata->ngeneratecuts[sepaidx])++;

   return SCIP_OKAY;
}

SCIP_RETCODE addCutToGeneratedCuts(
   SCIP* scip,
   GCG_MASTERCUTDATA* mastercutdata
)
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   SCIP_SEPA* sepa;
   int sepaidx;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(mastercutdata != NULL);

   eventhdlr = SCIPfindEventhdlr(scip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIP_CALL( GCGmastercutGetRow(mastercutdata, &row) );
   assert(row != NULL);

   sepa = SCIProwGetOriginSepa(row);
   assert(sepa != NULL);

   sepaidx = SCIPhashmapGetImageInt(eventhdlrdata->sepaxidx, sepa);
   assert(sepaidx != INT_MAX);

   SCIPdebugMessage("Added row %s from separator (%s, %i) to generatedcuts\n", SCIProwGetName(row), SCIPsepaGetName(sepa), sepaidx);
   SCIP_CALL( ensureGeneratedSize(scip, eventhdlrdata, sepaidx, eventhdlrdata->ngeneratecuts[sepaidx] + 1) );
   eventhdlrdata->generatedcuts[sepaidx][eventhdlrdata->ngeneratecuts[sepaidx]] = mastercutdata;
   SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxgeneratedidx, row, eventhdlrdata->ngeneratecuts[sepaidx]) );
   (eventhdlrdata->ngeneratecuts[sepaidx])++;

   return SCIP_OKAY;
}

SCIP_RETCODE clearGeneratedCuts(
   SCIP* scip
   )
{
   SCIP_EVENTHDLR* eventhdlr;
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_ROW* row;
   int i;
   int j;

   assert(scip != NULL);
   assert(GCGisMaster(scip));

   eventhdlr = SCIPfindEventhdlr(scip, EVENTHDLR_NAME);
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   /* clear out generatedcuts array */
   for( i = 0; i < eventhdlrdata->nsepas; i++ )
   {
      for( j = 0; j < eventhdlrdata->ngeneratecuts[i]; j++ )
      {
         if( eventhdlrdata->generatedcuts[i][j] != NULL  )
         {
            SCIP_CALL( GCGmastercutGetRow(eventhdlrdata->generatedcuts[i][j], &row) );
            assert(row != NULL);

            /* if cut was never in LP: we need to free mastercutdata */
            if( !SCIPhashmapExists(eventhdlrdata->rowxallidx, row) )
               SCIP_CALL( GCGmastercutFree(scip, &(eventhdlrdata->generatedcuts[i][j])) );
         }
      }
      eventhdlrdata->ngeneratecuts[i] = 0;
   }

   /* clear corresponding map */
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedidx);

   return SCIP_OKAY;
}
/*
 * Callback methods of event handler
 */


/** destructor of event handler to free user data (called when SCIP is exiting) */
static
SCIP_DECL_EVENTFREE(eventFreeMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;

   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIPdebugMessage("EVENT FREE\n");
   SCIPdebugMessage("free hashmaps\n");
   SCIPhashmapFree(&(eventhdlrdata->rowxallidx));
   SCIPhashmapFree(&(eventhdlrdata->rowxgeneratedidx));
   SCIPhashmapFree(&(eventhdlrdata->sepaxidx));

   /* free all the arrays */
   if( eventhdlrdata->nsepas > 0)
   {
      SCIPdebugMessage("free mem for (n)activecuts, (n)allcuts, (n)generatedcuts\n");
      for( i = eventhdlrdata->nsepas - 1; i >= 0 ; i-- )
      {
         SCIPdebugMessage("free mem (%i) for sepa %i\n", eventhdlrdata->allcutssize[i], i);
         SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->allcuts[i]), eventhdlrdata->allcutssize[i]);
         SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts[i]), eventhdlrdata->generatecutssize[i]);
      }
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->allcuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->nallcuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->ngeneratecuts), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->generatecutssize), eventhdlrdata->nsepas);
      SCIPfreeBlockMemoryArray(scip, &(eventhdlrdata->allcutssize), eventhdlrdata->nsepas);
   }
   else
   {
      SCIPdebugMessage("No sepas registered: arrays remained NULL --> nothing to free\n");
   }
   SCIPdebugMessage("free event handler data\n");
   SCIPfreeBlockMemory(scip, &eventhdlrdata);

   return SCIP_OKAY;
}

/** initialization method of event handler (called after problem was transformed) */
static
SCIP_DECL_EVENTINIT(eventInitMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_SEPA** sepas;
   int initialsize;
   int nsepas;
   int i;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);
   SCIPdebugMessage("EVENT INIT\n");

   /* initialize event handler data:
    * - each separator gets own array of active/all/generated cuts */
   nsepas = GCGrelaxGetNSeparators(scip);
   sepas = GCGrelaxGetSeparators(scip);
   if( nsepas > 0 )
   {
      SCIPdebugMessage("alloc mem for (n)activecuts, (n)allcuts, (n)generatedcuts\n");
      initialsize = SCIPcalcMemGrowSize(scip, STARTMAXCUTS);
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->allcuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->nallcuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->ngeneratecuts), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->allcutssize), nsepas) );
      SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatecutssize), nsepas) );

      for( i = 0; i < nsepas; i++ )
      {
         SCIPdebugMessage("alloc block mem (%i) for sepa %i\n", initialsize, i);
         SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->allcuts[i]), initialsize) );
         SCIP_CALL( SCIPallocBlockMemoryArray(scip, &(eventhdlrdata->generatedcuts[i]), initialsize) );
         eventhdlrdata->nallcuts[i] = 0;
         eventhdlrdata->ngeneratecuts[i] = 0;
         eventhdlrdata->generatecutssize[i] = initialsize;
         eventhdlrdata->allcutssize[i] = initialsize;
         SCIP_CALL( SCIPhashmapInsertInt(eventhdlrdata->sepaxidx, sepas[i]->separator, i) );
      }
   }
   else
   {
      SCIPdebugMessage("Detected no registered Separators --> no need to alloc mem for arrays: set to NULL\n");
      eventhdlrdata->allcuts = NULL;
      eventhdlrdata->generatedcuts = NULL;
      eventhdlrdata->nallcuts = NULL;
      eventhdlrdata->ngeneratecuts = NULL;
      eventhdlrdata->generatecutssize = NULL;
      eventhdlrdata->allcutssize = NULL;
   }
   SCIPdebugMessage("Set nsepas to %i", nsepas);
   eventhdlrdata->nsepas = nsepas;
   /* notify SCIP that event handler wants to react on the event types row added to LP and row deleted from LP */
   SCIP_CALL( SCIPcatchEvent(scip, SCIP_EVENTTYPE_ROWDELETEDLP | SCIP_EVENTTYPE_ROWADDEDLP | SCIP_EVENTTYPE_NODEDELETE, eventhdlr, NULL, NULL) );
   return SCIP_OKAY;
}

/** deinitialization method of event handler (called before transformed problem is freed)
 * - clean up branch-and-bound specific data */
static
SCIP_DECL_EVENTEXITSOL(eventExitSolMastercutUpdate)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   int i;
   int j;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert(eventhdlrdata != NULL);

   SCIPdebugMessage("EVENT EXITSOL\n");
   /* notify SCIP that your event handler wants to drop the event type lp solved and solution found */
   SCIP_CALL( SCIPdropEvent(scip, SCIP_EVENTTYPE_ROWDELETEDLP | SCIP_EVENTTYPE_ROWADDEDLP | SCIP_EVENTTYPE_NODEDELETE, eventhdlr, NULL, -1) );

   /* free all the remaining cuts from arrays */
   if( eventhdlrdata->nsepas > 0)
   {
      for( i = eventhdlrdata->nsepas - 1; i >= 0 ; i-- )
      {
         SCIPdebugMessage("free remaining mastercuts in  generatedcuts (%i) for sepa %i\n", i,
                          eventhdlrdata->ngeneratecuts[i]);

         for( j = 0; j < eventhdlrdata->ngeneratecuts[i]; j++ )
         {
            assert(eventhdlrdata->generatedcuts[i][j] != NULL);
            SCIP_CALL( GCGmastercutFree(scip, &eventhdlrdata->generatedcuts[i][j]) );
            assert(eventhdlrdata->generatedcuts[i][j] == NULL);
         }
         eventhdlrdata->ngeneratecuts[i] = 0;
         SCIPdebugMessage("free remaining storedcuts (%i) for sepa %i\n", i, eventhdlrdata->nallcuts[i]);
         for( j = 0; j < eventhdlrdata->nallcuts[i]; j++ )
         {
            assert(eventhdlrdata->allcuts[i][j] != NULL);
            SCIP_CALL( freeStoredCut(scip, &eventhdlrdata->allcuts[i][j]) );
            assert(eventhdlrdata->allcuts[i][j] == NULL);
         }
         eventhdlrdata->nallcuts[i] = 0;
      }
   }
   else
   {
      SCIPdebugMessage("No sepas were registered: array remained NULL --> nothing to free\n");
   }
   SCIPdebugMessage("clear hashmaps\n");
   SCIPhashmapRemoveAll(eventhdlrdata->rowxallidx);
   SCIPhashmapRemoveAll(eventhdlrdata->rowxgeneratedidx);
   SCIPhashmapRemoveAll(eventhdlrdata->sepaxidx);

   return SCIP_OKAY;
}

/** main execution method of event handler */
static
SCIP_DECL_EVENTEXEC(eventExecRowAdded)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_MASTERCUTDATA* mastercutdata;
   GCG_STOREDCUT* storedcut;
   SCIP_ROW* mastercutrow;
   SCIP_ROW* row;
   SCIP_SEPA* sepa;
   int sepaidx;
   int generatedidx;
   int allidx;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWADDEDLP);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert( eventhdlrdata != NULL );

   row = SCIPeventGetRow(event);
   sepa = SCIProwGetOriginSepa(row);

   /* if row was not generated by separator: nothing to do */
   if( sepa == NULL )
   {
      SCIPdebugMessage("row added event: cut was not generated by separator\n");
      return SCIP_OKAY;
   }

   sepaidx = SCIPhashmapGetImageInt(eventhdlrdata->sepaxidx, sepa);
   //assert(sepaidx != INT_MAX);
   SCIPdebugMessage("row added event: cut was generated by sepa (%s, %i)\n", SCIPsepaGetName(sepa), sepaidx);
   /* row is newly generated cut */
   if( SCIPisLPConstructed(scip) )
   {
      if( SCIPhashmapExists(eventhdlrdata->rowxgeneratedidx, row) )
      {
         SCIPdebugMessage("row added event: row is newly generated\n");
         /* get mastercutdata for row */
         generatedidx = SCIPhashmapGetImageInt(eventhdlrdata->rowxgeneratedidx, row);
         mastercutdata = eventhdlrdata->generatedcuts[sepaidx][generatedidx];

         /* add corresponding storedcut to allcuts */
         SCIP_CALL( ensureAllSize(scip, eventhdlrdata, sepaidx, eventhdlrdata->nallcuts[sepaidx] + 1) );
         SCIP_CALL( createStoredCut(scip, &storedcut, mastercutdata) );
         eventhdlrdata->allcuts[sepaidx][eventhdlrdata->nallcuts[sepaidx]] = storedcut;
         SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxallidx, row, eventhdlrdata->nallcuts[sepaidx]) );
         (eventhdlrdata->nallcuts[sepaidx])++;
      }
   }
   /* row is a re-activated cut */
   else if( SCIPhashmapExists(eventhdlrdata->rowxallidx, row) )
   {
      /* get mastercutdata for row */
      allidx =  SCIPhashmapGetImageInt(eventhdlrdata->rowxallidx, row);
      storedcut = eventhdlrdata->allcuts[sepaidx][allidx];
      assert(storedcut != NULL);
      assert(storedcut->mastercutdata != NULL);
      SCIP_CALL(GCGmastercutGetRow(storedcut->mastercutdata, &mastercutrow));
      assert(row == mastercutrow);

      /* row is global:  */
      if( !SCIProwIsLocal(row) )
      {
         /* add current focusnode to rows sourcenodes + no need to update as row did not miss any vars */
         SCIPdebugMessage("add row event: row re-added and  global --> add focusnode to sources\n");
         SCIP_CALL( ensureSourceNodesSize(scip, storedcut, storedcut->nsourcenodes + 1) );
         storedcut->sourcenode[storedcut->nsourcenodes] = SCIPnodeGetNumber(SCIPgetFocusNode(scip));
         (storedcut->nsourcenodes)++;
      }
      else
      {
         SCIPdebugMessage("add row event: row re-added and local --> update with missed variables\n");
         // @todo: update row with missed variables
      }
   }

   return SCIP_OKAY;
}

SCIP_RETCODE removeStoredCut(
   SCIP* scip,
   SCIP_EVENTHDLRDATA* eventhdlrdata,
   SCIP_ROW* row,
   int sepaidx,
   int allidx
   )
{
   GCG_STOREDCUT* storedcut;
   SCIP_ROW* mastercutrow;

   storedcut = eventhdlrdata->allcuts[sepaidx][allidx];

   /* all data related to this row can be removed */
   freeStoredCut(scip, &storedcut);

   /* remove pointer from allcuts array */
   SCIPdebugMessage("remove row %s allcuts\n", SCIProwGetName(row));
   (eventhdlrdata->nallcuts[sepaidx])--;
   eventhdlrdata->allcuts[sepaidx][allidx] = eventhdlrdata->allcuts[sepaidx][eventhdlrdata->nallcuts[sepaidx]];

   /* adapt index of moved entry in hashmap */
   if( allidx < eventhdlrdata->nallcuts[sepaidx] )
   {
      storedcut = eventhdlrdata->allcuts[sepaidx][allidx];
      SCIP_CALL( GCGmastercutGetRow(storedcut->mastercutdata, &mastercutrow) );
      SCIPdebugMessage("update allcuts hashmap: row %s has new index %i\n", SCIProwGetName(mastercutrow), allidx);
      SCIP_CALL( SCIPhashmapSetImageInt(eventhdlrdata->rowxallidx, mastercutrow, allidx) );
   }

   /* remove entry from hashmap and free indextuple of removed entry */
   SCIPhashmapRemove(eventhdlrdata->rowxallidx, row);
   return SCIP_OKAY;
}

/** main execution method of event handler */
static
SCIP_DECL_EVENTEXEC(eventExecRowDeleted)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_STOREDCUT* storedcut;
   SCIP_ROW* mastercutrow;
   SCIP_ROW* row;
   SCIP_SEPA* sepa;
   int allidx;
   int sepaidx;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_ROWDELETEDLP);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert( eventhdlrdata != NULL );

   row = SCIPeventGetRow(event);
   sepa = SCIProwGetOriginSepa(row);

   /* if row was not generated by separator: nothing to do */
   if( sepa == NULL )
   {
      SCIPdebugMessage("delete row event: cut was not generated by separator: nothing to delete\n");
      return SCIP_OKAY;
   }

   SCIPdebugMessage("delete row event: cut was generated by sepa\n");
   if( SCIPhashmapExists(eventhdlrdata->rowxallidx, row) )
   {
      /* retrieve corresponding mastercut data */
      sepaidx = SCIPhashmapGetImageInt(eventhdlrdata->sepaxidx, sepa);
      assert(sepaidx != INT_MAX);

      allidx = SCIPhashmapGetImageInt(eventhdlrdata->rowxallidx, row);
      storedcut = eventhdlrdata->allcuts[sepaidx][allidx];
      SCIP_CALL( GCGmastercutGetRow(storedcut->mastercutdata, &mastercutrow) );
      assert(mastercutrow == row);

      /* LP is already constructed: row is removed during solving --> row may never be used again */
      if( SCIPisLPConstructed(scip) ) //
      {
         SCIP_CALL(GCGmastercutGetRow(storedcut->mastercutdata, &mastercutrow) );
         assert(mastercutrow == row);

         /* row is currently only associated with one node */
         if( storedcut->nsourcenodes == 1 )
         {
            /* if row was created at current focusnode: row cannot be re-added later on */
            if( storedcut->sourcenode[0] == SCIPnodeGetNumber(SCIPgetFocusNode(scip)) )
            {
               SCIPdebugMessage("delete row event: row was created at current node and is therefore removed forever\n");
               SCIP_CALL( removeStoredCut(scip, eventhdlrdata, row, sepaidx, allidx) );
               return SCIP_OKAY;
            }
         }
         else if( storedcut->nsourcenodes > 1 )
         {
            assert(!SCIProwIsLocal(row));
            SCIPdebugMessage("delete row event: row is global and still stored in other nodes\n");
            /* if row was created at current focusnode: remove current node from source nodes */
            if( storedcut->sourcenode[storedcut->nsourcenodes - 1] == SCIPnodeGetNumber(SCIPgetFocusNode(scip)) )
            {

               SCIPdebugMessage("delete row event: removed current focusnode from sourcenodes\n");
               (storedcut->nsourcenodes)--;
            }
            /* else: row was removed while transforming focusnode to subtree node */
         }
      }
      /* row is deleted during the LP construction */
      else
      {
         SCIPdebugMessage("delete row event: row is deleted during LP construction\n");
      }
      /* forward history of cut */
      SCIPdebugMessage("delete row event: update varhistory\n");
      SCIP_CALL( GCGvarhistoryJumpToLatest(scip, &(storedcut->knownvarhistory)) );
   }
   return SCIP_OKAY;
}


static
SCIP_DECL_EVENTEXEC(eventExecNodeDeleted)
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   GCG_STOREDCUT* storedcut;
   SCIP_NODE* node;
   SCIP_SEPA* sepa;
   SCIP_ROW** rows;
   long long int nodenumber;
   int sepaidx;
   int nrows;
   int idx;
   int i;
   int j;
   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(eventhdlr != NULL);
   assert(event != NULL);
   assert(SCIPeventGetType(event) == SCIP_EVENTTYPE_NODEDELETE);

   eventhdlrdata = SCIPeventhdlrGetData(eventhdlr);
   assert( eventhdlrdata != NULL );

   node = SCIPeventGetNode(event);
   assert(node != NULL);

   switch ( SCIPnodeGetType(node) )
   {
      case SCIP_NODETYPE_FORK:
         rows = node->data.fork->addedrows;
         nrows = node->data.fork->naddedrows;
         break;
      case SCIP_NODETYPE_PSEUDOFORK:
         rows = node->data.pseudofork->addedrows;
         nrows = node->data.pseudofork->naddedrows;
         break;
      case SCIP_NODETYPE_SUBROOT:
         rows = node->data.subroot->rows;
         nrows = node->data.subroot->nrows;
         break;
      default:
         SCIPdebugMessage("node deletion event: node had no rows stored\n");
         return SCIP_OKAY;
   }

   for( i = 0; i < nrows; i++ )
   {
      sepa = SCIProwGetOriginSepa(rows[i]);
      if( sepa == NULL )
         continue;

      sepaidx = SCIPhashmapGetImageInt(eventhdlrdata->sepaxidx, sepa);
      SCIPdebugMessage("delete node event: row %s was generated by sepa %i\n", SCIProwGetName(rows[i]), sepaidx);
      if( SCIPhashmapExists(eventhdlrdata->rowxallidx, rows[i]) )
      {
         idx = SCIPhashmapGetImageInt(eventhdlrdata->rowxallidx, rows[i]);

         if( SCIPnodeGetType(node) != SCIP_NODETYPE_SUBROOT && SCIProwIsLocal(rows[i]) )
         {
            SCIPdebugMessage("delete node event: row is a local row stored at a (pseudo)fork: removed forever\n");
            SCIP_CALL( removeStoredCut(scip, eventhdlrdata, rows[i], sepaidx, idx) );
            continue;
         }
         else
         {
            storedcut = eventhdlrdata->allcuts[sepaidx][idx];
            nodenumber = SCIPnodeGetNumber(node);

            /* only node where this global cut is still stored */
            if( storedcut->nsourcenodes == 1 && storedcut->sourcenode[0] == nodenumber )
            {
               SCIPdebugMessage("delete node event: last node row was stored at --> remove forever\n");
               SCIP_CALL( removeStoredCut(scip, eventhdlrdata, rows[i], sepaidx, idx) );
               continue;
            }

            for( j = storedcut->nsourcenodes - 1; j >= 0 ; --j )
            {
               /* remove the node as row will no longer be stored at node */
               if( storedcut->sourcenode[j] == nodenumber )
               {
                  SCIPdebugMessage("delete node event: row remains, but node is removed from sources\n");
                  (storedcut->nsourcenodes)--;
                  storedcut->sourcenode[j] = storedcut->sourcenode[storedcut->nsourcenodes];
                  break;
               }
            }
         }
      }
   }

   return SCIP_OKAY;
}

/** main execution method of event handler */
static
SCIP_DECL_EVENTEXEC(eventExecMastercutUpdate)
{
   assert(scip != NULL);
   assert(eventhdlr != NULL);
   assert(strcmp(SCIPeventhdlrGetName(eventhdlr), EVENTHDLR_NAME) == 0);
   SCIPdebugMessage("event Exec\n");
   switch (SCIPeventGetType(event))
   {
      case SCIP_EVENTTYPE_ROWADDEDLP:
         SCIP_CALL( eventExecRowAdded(scip, eventhdlr, event, eventdata) );
         break;
      case SCIP_EVENTTYPE_ROWDELETEDLP:
         SCIP_CALL( eventExecRowDeleted(scip, eventhdlr, event, eventdata) );
         break;
      case SCIP_EVENTTYPE_NODEDELETE:
         SCIP_CALL( eventExecNodeDeleted(scip, eventhdlr, event, eventdata) );
         break;
      default:
         SCIPerrorMessage("unrecognized eventtype in mastercutupdate event handler\n");
         return SCIP_ERROR;
   }

   return SCIP_OKAY;
}



/** creates event handler for xyz event */
SCIP_RETCODE SCIPincludeEventHdlrSepaCuts(
   SCIP*                 scip                /**< SCIP data structure */
   )
{
   SCIP_EVENTHDLRDATA* eventhdlrdata;
   SCIP_EVENTHDLR* eventhdlr;

   /* create event handler data */
   SCIPdebugMessage("Include Sepa Cut Event Handler\n");
   SCIPdebugMessage("Alloc Block Memory for eventhandler data\n");
   SCIP_CALL( SCIPallocBlockMemory(scip, &eventhdlrdata) );
   assert(eventhdlrdata != NULL);
   SCIPdebugMessage("Create Hashmaps and set nsepas to 0\n");
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->rowxallidx), SCIPblkmem(scip), STARTMAXCUTS) );
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->rowxgeneratedidx), SCIPblkmem(scip), STARTMAXCUTS) );
   SCIP_CALL( SCIPhashmapCreate(&(eventhdlrdata->sepaxidx), SCIPblkmem(scip), 10) );
   eventhdlrdata->nsepas = 0;
   /* use SCIPincludeEventhdlrBasic() plus setter functions if you want to set callbacks one-by-one and your code should
    * compile independent of new callbacks being added in future SCIP versions
    */
   eventhdlr = NULL;
   SCIP_CALL( SCIPincludeEventhdlrBasic(scip, &eventhdlr, EVENTHDLR_NAME, EVENTHDLR_DESC,
         eventExecMastercutUpdate, eventhdlrdata) );
   assert(eventhdlr != NULL);

   /* set non fundamental callbacks via setter functions */
   SCIP_CALL( SCIPsetEventhdlrInit(scip, eventhdlr, eventInitMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrExitsol(scip, eventhdlr, eventExitSolMastercutUpdate) );
   SCIP_CALL( SCIPsetEventhdlrFree(scip, eventhdlr, eventFreeMastercutUpdate) );

   return SCIP_OKAY;
}
