/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program                         */
/*          GCG --- Generic Column Generation                                */
/*                  a Dantzig-Wolfe decomposition based extension            */
/*                  of the branch-cut-and-price framework                    */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/* Copyright (C) 2010-2024 Operations Research, RWTH Aachen University       */
/*                         Zuse Institute Berlin (ZIB)                       */
/*                                                                           */
/* This program is free software; you can redistribute it and/or             */
/* modify it under the terms of the GNU Lesser General Public License        */
/* as published by the Free Software Foundation; either version 3            */
/* of the License, or (at your option) any later version.                    */
/*                                                                           */
/* This program is distributed in the hope that it will be useful,           */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU Lesser General Public License for more details.                       */
/*                                                                           */
/* You should have received a copy of the GNU Lesser General Public License  */
/* along with this program; if not, write to the Free Software               */
/* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.*/
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   mastersepacut.c
 * @brief  data structures to store all the relevant data for cuts generated by master separators
 * @author Chantal Reinartz Groba
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/
#include <scip/type_scip.h>

#include "gcg.h"
#include "mastersepacut.h"
#include "struct_mastersepacut.h"
#include "struct_sepagcg.h"
#include "type_mastersepacut.h"
#include "type_gcgcol.h"
#include "gcgcol.h"
#include "pub_gcgcol.h"



/** frees data of subset row cut */
static
SCIP_RETCODE freeSubsetRowCutData(
   SCIP*                      masterscip,    /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUTDATA**    data           /**< pointer to data of subset row cut */
   )
{
   if( *data == NULL )
      return SCIP_OKAY;

   if( (*data)->data.subsetrowcutdata.n > 0 )
   {
      SCIPfreeBlockMemoryArrayNull(masterscip, &((*data)->data.subsetrowcutdata.weights), (*data)->data.subsetrowcutdata.n);
      SCIPfreeBlockMemoryArrayNull(masterscip, &((*data)->data.subsetrowcutdata.conssindices), (*data)->data.subsetrowcutdata.n);
      (*data)->data.subsetrowcutdata.n = 0;
   }

   assert((*data)->data.subsetrowcutdata.weights == NULL);
   assert((*data)->data.subsetrowcutdata.conssindices == NULL);
   assert((*data)->data.subsetrowcutdata.n == 0);

   SCIPfreeBlockMemory(masterscip, data);
   *data = NULL;

   return SCIP_OKAY;
}

/** frees master separator cut */
static
SCIP_RETCODE freeMasterSepaCut(
   SCIP*                masterscip,       /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT**  mastersepacut     /**< pointer to master separator cut */
)
{
   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(mastersepacut != NULL);
   assert(*mastersepacut != NULL);

#ifdef SCIP_DEBUG
   SCIP_ROW* row;
   SCIP_CALL( GCGmastercutGetRow((*mastersepacut)->mastercutdata, &row) );
   SCIPdebugMessage("free master separator cut: free cut for row %s\n", SCIProwGetName(row));
#endif

   if( (*mastersepacut)->knownvarhistory != NULL )
   {
      SCIPdebugMessage("free mastersepacut: var history is freed\n");
      SCIP_CALL( GCGvarhistoryFreeReference(masterscip, &((*mastersepacut)->knownvarhistory)) );
   }
   assert((*mastersepacut)->knownvarhistory == NULL);

   if( (*mastersepacut)->mastercutdata != NULL )
   {
      SCIP_CALL( GCGmastercutFree(masterscip, &((*mastersepacut)->mastercutdata)) );
   }
   assert((*mastersepacut)->mastercutdata == NULL);

   if( (*mastersepacut)->cuttype == GCG_MASTERSEPACUTTYPE_SUBSETROW )
   {
      SCIP_CALL( freeSubsetRowCutData(masterscip, &((*mastersepacut)->data)) );
   }
   assert((*mastersepacut)->data == NULL);

   SCIPfreeBlockMemory(masterscip, mastersepacut);
   *mastersepacut = NULL;

   return SCIP_OKAY;
}

/** increases usage counter of master separator cut */
SCIP_RETCODE GCGcaptureMasterSepaCut(
   GCG_MASTERSEPACUT*      mastersepacut      /**< master separator cut */
)
{
   assert(mastersepacut != NULL);
   assert(mastersepacut->nuses >= 0);

#ifdef SCIP_DEBUG
   SCIP_ROW* row;
   SCIP_CALL( GCGmastercutGetRow(mastersepacut->mastercutdata, &row) );
   SCIPdebugMessage("capture master separator cut: row %s now has %i nuses\n", SCIProwGetName(row), mastersepacut->nuses);
#endif
   (mastersepacut->nuses)++;

   return SCIP_OKAY;
}

/** decreases usage counter of master separator cut, and frees memory if necessary */
SCIP_RETCODE GCGreleaseMasterSepaCut(
   SCIP*                   masterscip,      /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT**     mastersepacut    /**< pointer to master separator cut */
)
{
   assert(masterscip != NULL);
   assert(mastersepacut != NULL);
   assert(*mastersepacut != NULL);
   assert((*mastersepacut)->nuses >= 0);

#ifdef SCIP_DEBUG
   SCIP_ROW* row;
   SCIP_CALL( GCGmastercutGetRow((*mastersepacut)->mastercutdata, &row) );
   SCIPdebugMessage("release master separator cut: row %s now has %i nuses\n", SCIProwGetName(row), (*mastersepacut)->nuses);
#endif

   ((*mastersepacut)->nuses)--;
   if( (*mastersepacut)->nuses == 0 )
   {
      SCIP_CALL( freeMasterSepaCut(masterscip, mastersepacut) );
   }

   *mastersepacut = NULL;

   return SCIP_OKAY;
}

/**< creates master separator cut */
SCIP_RETCODE GCGcreateMasterSepaCut(
   SCIP*                   masterscip,          /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT**     mastersepacut,       /**< pointer to store master separator cut */
   GCG_MASTERSEPACUTTYPE   mastersepacuttype,   /**< type of master separator cut */
   GCG_SEPA*               sepa,                /**< separator creating this cut */
   GCG_MASTERCUTDATA*      mastercutdata,       /**< master cut data */
   GCG_VARHISTORY*         varhistory,          /**< variable history */
   GCG_MASTERSEPACUTDATA*  mastersepacutdata    /**< master separator cut data */
   )
{
   assert(masterscip != NULL);
   assert(mastercutdata != NULL);
   assert(mastersepacut != NULL);
   assert(GCGisMaster(masterscip));

   SCIP_CALL( SCIPallocBlockMemory(masterscip, mastersepacut) );
   (*mastersepacut)->mastercutdata = mastercutdata;
   (*mastersepacut)->nuses = 0;
   (*mastersepacut)->knownvarhistory = varhistory;
   (*mastersepacut)->cuttype = mastersepacuttype;
   (*mastersepacut)->data = mastersepacutdata;
   (*mastersepacut)->sepa = sepa;

   SCIP_CALL( GCGcaptureMasterSepaCut(*mastersepacut) );

   return SCIP_OKAY;
}

/**< returns the master cut data of the master separator cut */
GCG_MASTERCUTDATA* GCGmastersepacutGetMasterCutData(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->mastercutdata;
}

/**< returns the variable history of the master separator cut */
GCG_VARHISTORY* GCGmastersepacutGetVarHistory(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->knownvarhistory;
}

/**< returns the cut type of the master separator cut */
GCG_MASTERSEPACUTTYPE GCGmastersepacutGetCutType(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
)
{
   assert(mastersepacut != NULL);

   return mastersepacut->cuttype;
}

/**< return the indexof the separator which created the cut */
int GCGmastersepacutGetSeparatorIndex(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->sepa->index;
}

/**< return the separator which created the cut */
GCG_SEPA* GCGmastersepacutGetSeparator(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
)
{
   assert(mastersepacut != NULL);

   return mastersepacut->sepa;
}

/**< returns the data of the master separator cut */
GCG_MASTERSEPACUTDATA* GCGmastersepacutGetData(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
)
{
   assert(mastersepacut != NULL);

   return mastersepacut->data;
}

/**< set the variable history of master separator cut */
SCIP_RETCODE GCGmastersepacutSetVarHistory(
   SCIP*                   masterscip,       /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT**     mastersepacut     /**< pointer to master separator cut */
   )
{
   assert(masterscip != NULL);
   assert(mastersepacut != NULL);
   assert(*mastersepacut != NULL);

#ifdef SCIP_DEBUG
   SCIP_ROW* row;
   SCIP_CALL( GCGmastercutGetRow((*mastersepacut)->mastercutdata, &row) );
   SCIPdebugMessage("set var history: set history for row %s\n", SCIProwGetName(row));
#endif

   SCIP_CALL( GCGvarhistoryCopyReference(masterscip, &((*mastersepacut)->knownvarhistory), GCGgetCurrentVarhistoryReference(masterscip)) );
   return SCIP_OKAY;
}


// SUBSETROW CUT SPECIFIC METHODS

/**< creates a subset row cut */
SCIP_RETCODE GCGcreateSubsetRowCut(
   SCIP*                   masterscip,            /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT**     mastersepacut,         /**< pointer to store master separator cut */
   GCG_SEPA*               sepa,                  /**< separator creating this cut */
   GCG_MASTERCUTDATA*      mastercutdata,         /**< mastercutdata associated with the cut */
   GCG_VARHISTORY*         varhistory,            /**< variables history of subset row cut*/
   SCIP_Real*              weights,               /**< weights which were used to create the cut */
   int*                    indices,               /**< indices of constraints used to create the cut */
   int                     n                      /**< number of constraints used to create the cut */
   )
{
   GCG_MASTERSEPACUTDATA* data;

   assert(masterscip != NULL);
   assert(GCGisMaster(masterscip));
   assert(mastersepacut != NULL);
   assert(n >= 0);

   SCIP_CALL( SCIPallocBlockMemory(masterscip, &data) );
   data->data.subsetrowcutdata.n = n;
   data->data.subsetrowcutdata.weights = NULL;
   data->data.subsetrowcutdata.conssindices = NULL;

   if( n > 0 )
   {
      SCIP_CALL( SCIPduplicateBlockMemoryArray(masterscip, &(data->data.subsetrowcutdata.weights), weights, n) );
      SCIP_CALL( SCIPduplicateBlockMemoryArray(masterscip, &(data->data.subsetrowcutdata.conssindices), indices, n) );
   }

   SCIP_CALL( GCGcreateMasterSepaCut(masterscip, mastersepacut, GCG_MASTERSEPACUTTYPE_SUBSETROW, sepa,
                                     mastercutdata, varhistory, data) );
   return SCIP_OKAY;
}

/**< returns TRUE or FALSE whether cut is a subset row cut */
SCIP_Bool GCGmastersepacutIsSubsetRow(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
   )
{
   assert(mastersepacut != NULL);

   return mastersepacut->cuttype == GCG_MASTERSEPACUTTYPE_SUBSETROW;
}

/**< returns the number of weights of subset row cut */
int GCGsubsetrowCutGetNWeights(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
   )
{
   GCG_MASTERSEPACUTDATA* data;

   assert(mastersepacut != NULL);
   assert(GCGmastersepacutIsSubsetRow(mastersepacut));

   data = GCGmastersepacutGetData(mastersepacut);
   assert(data != NULL);

   return data->data.subsetrowcutdata.n;
}

/**< returns the weights of subset row cut */
SCIP_Real* GCGsubsetrowCutGetWeights(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
)
{
   GCG_MASTERSEPACUTDATA* data;

   assert(mastersepacut != NULL);
   assert(GCGmastersepacutIsSubsetRow(mastersepacut));

   data = GCGmastersepacutGetData(mastersepacut);
   assert(data != NULL);

   return data->data.subsetrowcutdata.weights;
}

/**< returns the constraint indices of subset row cut */
int* GCGsubsetrowCutGetConssIndices(
   GCG_MASTERSEPACUT*      mastersepacut     /**< master separator cut */
)
{
   GCG_MASTERSEPACUTDATA* data;

   assert(mastersepacut != NULL);
   assert(GCGmastersepacutIsSubsetRow(mastersepacut));

   data = GCGmastersepacutGetData(mastersepacut);
   assert(data != NULL);

   return data->data.subsetrowcutdata.conssindices;
}

/** computes the coefficient of a column for a master separator cut */
SCIP_RETCODE GCGsubsetrowCutGetColumnCoefficient(
   SCIP*                   scip,       /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT*      cut,        /**< master separator cut */
   GCG_COL*                gcgcol,     /**< gcg column */
   SCIP_Real*              coeff       /**< pointer to store the coefficient */
)
{
   SCIP_Real*     weights;
   SCIP_Real*     mastercoeffs;
   int*           conssindices;
   int            n;
   int            i;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(gcgcol != NULL);
   assert(GCGcolGetInitializedCoefs(gcgcol));

   mastercoeffs = GCGcolGetMastercoefs(gcgcol);
   weights = GCGsubsetrowCutGetWeights(cut);
   conssindices = GCGsubsetrowCutGetConssIndices(cut);
   n = GCGsubsetrowCutGetNWeights(cut);
   assert(mastercoeffs != NULL);
   assert(weights != NULL);
   assert(conssindices != NULL);

   /* use the coefficients of the master constraints to compute coefficient for cut */
   *coeff = 0.0;
   for( i = 0; i < n; i++ )
   {
      SCIPdebugMessage("w[%i]: %f, i[%i]: %i --> %f\n", i, weights[i], i, conssindices[i], mastercoeffs[conssindices[i]]);
      *coeff += weights[i] * mastercoeffs[conssindices[i]];
   }

   *coeff = SCIPfeasFloor(scip, *coeff);
   SCIPdebugMessage("column coefficient: %f\n", *coeff);
   return SCIP_OKAY;
}

/** computes the coefficient of a master variable for a master separator cut */
SCIP_RETCODE GCGsubsetrowCutGetVariableCoefficient(
   SCIP*                scip,       /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT*   cut,        /**< master separator cut */
   SCIP_VAR**           vars,       /**< pricing variables which define the master variable */
   SCIP_Real*           vals,       /**< values of the pricing variables which define the master variables */
   int                  nvars,      /**< number of pricing variables which define the master variable */
   int                  probnr,     /**< index of the pricing problem which generated the master variable */
   SCIP_Real*           coef        /**< pointer to store the coefficient */
)
{
   SCIP*                      origscip;
   SCIP*                      pricingscip;
   GCG_PRICINGMODIFICATION*   pricingmod;
   GCG_MASTERCUTDATA*         mastercutdata;
   SCIP_CONS**                pricingconss;
   SCIP_VAR**                 pricingconsvars;
   SCIP_Bool                  success;
   SCIP_Bool                  found;
   SCIP_Real*                 pricingconscoeffs;
   int                        npricingconsvars;
   int                        i;
   int                        pos;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(cut != NULL);

   *coef = 0.0;
   mastercutdata = GCGmastersepacutGetMasterCutData(cut);
   assert(mastercutdata != NULL);
   pricingmod = GCGmastercutGetPricingModification(scip, mastercutdata, probnr);

   /* no pricing modification for this problem: coefficient is zero */
   if( pricingmod == NULL )
   {
      SCIPdebugMessage("no pricing modification for pp%i --> variable coefficient 0\n", probnr);
      return SCIP_OKAY;
   }

   /* get the pricing modification of the problem which generated this master variable */
   origscip = GCGgetOriginalprob(scip);
   assert(origscip != NULL);
   pricingscip = GCGgetPricingprob(origscip, probnr);
   pricingconss = GCGpricingmodificationGetAdditionalConss(pricingmod);

   /* get all the pricing variables and their coefficients in the constraint */
   SCIP_CALL( SCIPgetConsNVars(pricingscip, pricingconss[0], &npricingconsvars, &success) );
   assert(success);
   SCIPallocBufferArray(scip, &pricingconsvars, npricingconsvars);
   SCIPallocBufferArray(scip, &pricingconscoeffs, npricingconsvars);
   SCIP_CALL( SCIPgetConsVars(pricingscip, pricingconss[0], pricingconsvars, npricingconsvars, &success) );
   assert(success);
   SCIP_CALL( SCIPgetConsVals(pricingscip, pricingconss[0], pricingconscoeffs, npricingconsvars, &success) );
   assert(success);

   /* compute w^TAx using the pricing constraint */
   for( i = 0; i < npricingconsvars; i++ )
   {
      if( GCGvarIsInferredPricing(pricingconsvars[i]) )
         continue;

      found = SCIPsortedvecFindPtr((void**) vars, SCIPvarComp, (void*) pricingconsvars[i], nvars, &pos);

      if( !found )
         continue;

      *coef += pricingconscoeffs[i] * vals[pos];
   }

   /* finally, we round down w^TAx */
   SCIPdebugMessage("variable coefficient %f\n", *coef);
   *coef = SCIPfeasFloor(scip, *coef);

   /* clean-up */
   SCIPfreeBufferArray(scip, &pricingconsvars);
   SCIPfreeBufferArray(scip, &pricingconscoeffs);

   return SCIP_OKAY;
}

/** adapts the objectives of all the necessary pricing problems such that they consider the master cut */
SCIP_RETCODE GCGsubsetrowSetPricingObjectives(
   SCIP*                   scip,    /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT*      cut,     /**< master separator cut */
   SCIP_Real               dual     /**< the dual value of the master separator cut */
)
{
   SCIP_ROW*                  row;
   SCIP*                      pricingproblem;
   SCIP*                      origscip;
   SCIP_VAR*                  coeffvar;
   GCG_PRICINGMODIFICATION*   pricingmodifications;
   GCG_MASTERCUTDATA*         mastercutdata;
   int                        npricingmodifications;
   int                        pricingblocknr;
   int                        i;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(cut != NULL);

   /* get all the pricing modifications associated with this master cut */
   origscip = GCGgetOriginalprob(scip);
   assert(origscip != NULL);
   mastercutdata = GCGmastersepacutGetMasterCutData(cut);
   assert(mastercutdata != NULL);
   npricingmodifications = GCGmastercutGetNPricingModifications(mastercutdata);
   pricingmodifications = GCGmastercutGetPricingModifications(mastercutdata);
   row = GCGmastercutGetRow(mastercutdata);
   assert(row != NULL);

   /* set the objective value of each coefficient variable y to -dual of the cut it is associated with */
   for( i = 0; i < npricingmodifications; i++ )
   {
      pricingblocknr = GCGpricingmodificationGetBlock(&pricingmodifications[i]);
      pricingproblem = GCGgetPricingprob(origscip, pricingblocknr);
      coeffvar = GCGpricingmodificationGetCoefVar(&pricingmodifications[i]);

      if( dual >= 0.0 ) // @todo: theoretically, dual should always be non-positive: 'correct' it to zero
         SCIP_CALL( SCIPchgVarObj(pricingproblem, coeffvar, 0.0) );
      else
         SCIP_CALL( SCIPchgVarObj(pricingproblem, coeffvar, -1.0 * dual) );
   }

   return SCIP_OKAY;
}

/** adapts a GCG column such that it respects the pricing modification imposed by the master separator cut */
SCIP_RETCODE GCGsubsetrowAdjustGCGColumn(
   SCIP*                scip,       /**< SCIP data structure (master problem) */
   GCG_MASTERSEPACUT*   cut,        /**< master separator cut */
   GCG_COL**            gcgcol      /**< gcg column */
)
{
   GCG_PRICINGMODIFICATION* pricemod;
   GCG_MASTERCUTDATA* mastercutdata;

   assert(scip != NULL);
   assert(GCGisMaster(scip));
   assert(cut != NULL);

   mastercutdata = GCGmastersepacutGetMasterCutData(cut);
   assert(mastercutdata != NULL);

   if( !GCGmastercutIsActive(mastercutdata) )
      return SCIP_OKAY;

   pricemod = GCGmastercutGetPricingModification(scip, mastercutdata, GCGcolGetProbNr(*gcgcol));
   if( pricemod != NULL )
   {
      SCIP_VAR* coefvar;
      SCIP_Real coefvarval;
      SCIP_Bool append = FALSE;
      SCIP_Bool insert = FALSE;
      int pos;

      coefvar = GCGpricingmodificationGetCoefVar(pricemod);
      assert(coefvar != NULL);

      if( SCIPvarGetIndex(coefvar) == -1 )
         return SCIP_OKAY;

      /* we compute the value of y */
      if( GCGcolGetInitializedCoefs(*gcgcol) )
         SCIP_CALL( GCGsubsetrowCutGetColumnCoefficient(scip, cut, *gcgcol, &coefvarval) );
      else
         SCIP_CALL( GCGsubsetrowCutGetVariableCoefficient(scip, cut, (*gcgcol)->vars, (*gcgcol)->vals, (*gcgcol)->nvars, (*gcgcol)->probnr, &coefvarval) );

      /* 1. variable already in column: replace value (this indicates that this was not the violating constraint)
       * 2. variable not yet in column:
       *    a. variable can be appended and variable order (based on index) remains correct
       *    b. variable has to be inserted to maintain the correct order */
      if( SCIPvarCompare((*gcgcol)->vars[(*gcgcol)->nvars - 1], coefvar) == -1 )
         append = TRUE; // variable can simply be appended (2.a)
      else
      {
         /* check if variable already in column */
         SCIP_VAR** vars;
         SCIP_Bool found;
         int nvars;

         vars = (*gcgcol)->vars;
         nvars = (*gcgcol)->nvars;

         /* search position variable should be at */
         found = SCIPsortedvecFindPtr((void**) vars, SCIPvarComp, (void*) coefvar, nvars, &pos);
         if( found )
            (*gcgcol)->vals[pos] = coefvarval; // variable already in column (1)
         else
            insert = TRUE; // variable needs to be inserted in column at position pos (2.b)
      }

      /* cases 2.a and 2.b */
      if( !SCIPisZero((*gcgcol)->pricingprob, coefvarval) && (append || insert))
      {
         /* ensure column has enough space to include variable */
         if( (*gcgcol)->maxvars < (*gcgcol)->nvars + 1 )
         {
            int newmaxvars = SCIPcalcMemGrowSize((*gcgcol)->pricingprob, (*gcgcol)->nvars + 1);
            SCIP_CALL( SCIPreallocBlockMemoryArray((*gcgcol)->pricingprob, &((*gcgcol)->vars), (*gcgcol)->maxvars,
                                                   newmaxvars) );
            SCIP_CALL( SCIPreallocBlockMemoryArray((*gcgcol)->pricingprob, &((*gcgcol)->vals), (*gcgcol)->maxvars,
                                                   newmaxvars) );
            (*gcgcol)->maxvars = newmaxvars;
         }

         if( append )
         {
            /* variable can simply be appended to array and order remains correct */
            (*gcgcol)->vars[(*gcgcol)->nvars] = coefvar;
            (*gcgcol)->vals[(*gcgcol)->nvars] = coefvarval;
            SCIPcaptureVar((*gcgcol)->pricingprob, (*gcgcol)->vars[(*gcgcol)->nvars]);
         }
         else if( insert )
         {
            int i = 0;

            /* we have to move all the variables (& and their values) stored behind pos */
            for( i = (*gcgcol)->nvars; i > pos ; i-- )
            {
               (*gcgcol)->vars[i] = (*gcgcol)->vars[i - 1];
               (*gcgcol)->vals[i] = (*gcgcol)->vals[i - 1];
            }

            /* add variable at correct position */
            (*gcgcol)->vars[pos] = coefvar;
            (*gcgcol)->vals[pos] = coefvarval;
            SCIPcaptureVar((*gcgcol)->pricingprob, (*gcgcol)->vars[pos]);
         }

         ((*gcgcol)->nvars)++;
      }
   }
   else
      SCIPinfoMessage(scip, NULL, "pricemod not found!\n");

   return SCIP_OKAY;
}
